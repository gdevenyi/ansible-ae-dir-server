############################################################################
# OpenLDAP configuration for AE-DIR {{ openldap_role }}
# This file MUST NOT be world-readable!
# {{ ansible_managed }}
############################################################################

{% include 'global.conf.j2' %}

#---------------------------------------------------------------------------
# password hash parameters
#---------------------------------------------------------------------------

password-hash {{ openldap_password_hash }}
{% if openldap_password_hash.upper()=='{CRYPT}' %}
password-crypt-salt-format "{{ openldap_password_crypt_salt_format }}"
{% endif %}

{% include 'config.conf.j2' %}

{% if aedir_accesslog_suffix %}
{% include 'accesslog.conf.j2' %}
{% endif %}

#######################################################################
# Database for {{ aedir_suffix }}
#######################################################################

database mdb

suffix "{{ aedir_suffix }}"
directory {{ openldap_data }}/um

require strong

# Always set rootdn since needed by internally writing overlays
rootdn "cn=root,{{ aedir_suffix }}"
# rootpw not needed in production!
#rootpw donotenable!!!
access to
  dn.base="cn=root,{{ aedir_suffix }}"
    by * none

lastmod on

# database parameters
maxsize {{ openldap_db_params.um.mdb_maxsize }}

{% if openldap_db_params.um.checkpoint %}
# Better write performance but less crash resistance, see slapd-mdb(5) for details
dbnosync
checkpoint {{ openldap_db_params.um.checkpoint }}
envflags writemap mapasync
{% endif %}

add_content_acl yes

#---------------------------------------------------------------------------
# Index configuration
#---------------------------------------------------------------------------

# general eq-only indexes

index objectClass eq
index uid eq
index departmentNumber eq
index uidNumber eq
index gidNumber eq
index member eq
index memberUid eq
index rfc822MailMember sub,eq
index memberURL pres
index memberOf eq
index sudoUser pres,eq
index seeAlso eq
index modifyTimestamp eq
index nickName eq
index mailLocalAddress sub,eq
index mailRoutingAddress sub,eq
# mainly for syncrepl
index entryCSN eq
index entryUUID eq

# for host and network management
index macAddress eq
index ipHostNumber eq,pres
index host sub,eq
index aeFqdn sub,eq,pres
index aeNwDevice eq

# for aeUser
index aeRemoteHost pres,eq

# sub and eq indexes
index cn sub,eq
index displayName sub,eq
index sn sub,eq
index givenName sub,eq
index mail sub,eq
index o sub,eq
index ou sub,eq

# service groups
index aeLoginGroups eq
index aeVisibleGroups eq
index aeVisibleSudoers eq
index aeProxyFor pres,eq
index aeSSHProxyCommand pres,eq,sub
index aeRequires eq

# zones
index aeZoneAdmins pres,eq
index aePasswordAdmins pres,eq
index aeZoneAuditors pres,eq
index aeABAccessGroups pres,eq

# service attributes
index aeHost eq

# login-related attributes
index authTimestamp pres,eq
index pwdChangedTime pres,eq
index pwdFailureTime pres,eq

# for person/employee references
index uniqueIdentifier eq
index employeeNumber eq
index aePerson eq
index aeDept eq
index aeLocation eq

# Meta data
index aeTicketId eq
index aeNotBefore,aeNotAfter pres,eq
index aeTag eq,sub

# hardware devices
index serialNumber eq,sub
index aeHwSerialNumber eq,sub
index aeOwner eq

# for OATH-LDAP (indexes only needed on provider)
index oathTokenIdentifier eq
index oathHOTPToken eq
index oathHOTPParams eq
index oathTOTPToken eq
index oathTOTPParams eq

#---------------------------------------------------------------------------
# search/time limits for {{ aedir_suffix }}
#---------------------------------------------------------------------------

# Maximum number of entries to return from a search operation
sizelimit {{ openldap_db_params.um.sizelimit }}

# Maximum number of time [secs] slapd will spend answering a search request
timelimit {{ openldap_db_params.um.timelimit }}

# no limits for AE admins
limits
  group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}"
    time=unlimited
    size=unlimited

# no limits for AE auditors
limits
  group/aeGroup/member="cn=ae-auditors,cn=ae,{{ aedir_suffix }}"
    time=unlimited
    size=unlimited

# no limits for all zone admins
limits
  group/aeGroup/member="cn=ae-all-zone-admins,cn=ae,{{ aedir_suffix }}"
    time=unlimited
    size=unlimited

# no limits for all zone auditors
limits
  group/aeGroup/member="cn=ae-all-zone-auditors,cn=ae,{{ aedir_suffix }}"
    time=unlimited
    size=unlimited

# no limits for replicas
limits
  group/aeGroup/member="cn=ae-replicas,cn=ae,{{ aedir_suffix }}"
    time=unlimited
    size=unlimited

#---------------------------------------------------------------------------
# access control rules for {{ aedir_suffix }}
#---------------------------------------------------------------------------

# First disallow non-active entities to proceed to rest of ACLs
# by allowing only auth
# This purposely also affects open LDAP connections!
#------------------------------------------------------------------

# block access to all other stuff (except userPassword)
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=!simpleSecurityObject
    by set="user/aeStatus & [0]" break
    by * auth

# give read access to pseudo-attribute 'entry' in database
# naming context to all users and stop further ACL processing
#------------------------------------------------------------------

access to
  dn.base="{{ aedir_suffix }}"
  attrs=entry
    by users read
    by * none

#---------------------------------------------------------------------------
# The replica ACLs MUST be before secret attributes' ACLs
#---------------------------------------------------------------------------

# Access control for entries/attributes only visible on provider replicas
#---------------------------------------------------------------------------

access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=authTimestamp,pwdFailureTime,pwdHistory,msPwdResetAdminPw
{% for restriction in aedir_providers_restrictions or [''] %}
    by {{ restriction }} group/aeGroup/member="cn=ae-providers,cn=ae,{{ aedir_suffix }}" read
{% endfor %}
    by group/aeGroup/member="cn=ae-replicas,cn=ae,{{ aedir_suffix }}" none
    by * none break

# OATH token, department, location and person entries only required on providers
access to
  filter="(|(objectClass=aeDept)(objectClass=aeLocation)(objectClass=aePerson)(objectClass=oathToken))"
{% for restriction in aedir_providers_restrictions or [''] %}
    by {{ restriction }} group/aeGroup/member="cn=ae-providers,cn=ae,{{ aedir_suffix }}" read
{% endfor %}
    by group/aeGroup/member="cn=ae-replicas,cn=ae,{{ aedir_suffix }}" none
    by * none break

# All replicas can read everything else
access to
  dn.subtree="{{ aedir_suffix }}"
{% for restriction in aedir_replicas_restrictions or [''] %}
    by {{ restriction }} group/aeGroup/member="cn=ae-replicas,cn=ae,{{ aedir_suffix }}" read
{% endfor %}
    by * none break

# Access control for various password attributes
#---------------------------------------------------------------------------

{% if aedir_pwsync_targeturl is defined %}
# grant read access to userPassword to password sync process
access to
{% if aedir_pwsync_dn_regex %}
  dn.regex="{{ aedir_pwsync_dn_regex }}"
{% else %}
  dn.subtree="{{ aedir_suffix }}"
{% endif %}
  attrs=entry,objectClass,userPassword
  filter="(&(|(objectClass=aeUser)(objectClass=aeService))(aeStatus=0)(userPassword=*))"
    by dn.base="uid={{ aedir_pwsync_listener_user }},cn=ae,{{ aedir_suffix }}" read
    by * none break
{% endif %}

# Password of active token entries may be
# 1. searched but not read or written by AE-DIR admins
# 2. written but not read by enrollment service
# 3. removed by self
# 4. used for LDAP simple bind
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=userPassword
  filter="(&(objectClass=oathToken)(aeStatus=0)(pwdPolicySubentry=cn=ppolicy-otptokens,cn=ae,{{ aedir_suffix }})(!(oathHOTPCounter=*)))"
    by dn.base="uid=ae-dir-otpenroll,cn=ae,{{ aedir_suffix }}" =w
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" =s
    by self =z
    by anonymous auth

# Safety net for bugs in (H/T)OTP validator:
# Block auth access to password of users with assigned OTP token
# because their simple bind requests must be always validated by
# external bind listener.
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=userPassword
  filter="(&(objectClass=aeUser)(aeStatus=0)(oathToken=*))"
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" =r
    by users none break
    by * none

# Password of active personal user accounts
# - can never be read by anyone
# - AE admins can search and write
# - AE auditors can search
# - password self-service app can write
# - user can write and search own password
# - anonymous can authenticate
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=userPassword
  filter="(&(objectClass=aeUser)(aeStatus=0))"
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" =sw
    by self =sw
    by group/aeGroup/member="cn=ae-auditors,cn=ae,{{ aedir_suffix }}" =s
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" =w
    by set="(user & this/-1/aePasswordAdmins/member) & (user & this/-1/aeZoneAdmins/member)" =w
    by anonymous auth

# Subordinate aeHost and aeService entries beneath aeSrvGroup entries
# Important note:
# aeService entries running locally on AE-DIR servers MUST NOT have
# userPassword attribute at all because they always MUST connect via LDAPI
# and bind with SASL/EXTERNAL
access to
  attrs=userPassword
  filter="(&(|(objectClass=aeHost)(objectClass=aeService))(aeStatus=0)(!(|(uidNumber<={{ aedir_min_uid-1 }})(gidNumber<={{ aedir_min_gid-1 }})(uidNumber>={{ aedir_max_uid+1 }})(gidNumber>={{ aedir_max_gid+1 }}))))"
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" =w
    by set="user & this/-2/aeZoneAdmins/member" =w
    by set="user & this/-1/aeZoneAdmins/member" =w
    by set="user & this/-1/aeSetupGroups/member" =w
    by anonymous auth

# no access to userPassword as last catch
access to
  attrs=userPassword
    by * none

# limited manage access (no read!) to pwdHistory only for AE-DIR admins
access to
  attrs=pwdHistory
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" =szm
    by * none

#------------------------------------------------------------------
# access to OATH-LDAP attribute 'oathSecret'
# Note: more OATH-LDAP related ACLs below
#------------------------------------------------------------------

# OTP validator can read oathSecret if token is initialized
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(&(objectClass=oathToken)(aeStatus=0)(oathHOTPCounter>=0))"
  attrs=oathSecret
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" read
    by * none break

# 1. AE admin can search and write but not read 'oathSecret'
# 2. Zone admin can delete but not read 'oathSecret'
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(&(objectClass=oathToken)(aeStatus=0))"
  attrs=oathSecret
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" =sw
    by set="user & this/-1/aeZoneAdmins/member" =z
    by * none break

# An uninitialized OATH token device can itself write (not read) some attributes
# (authenticated with enrollment userPassword value)
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(&(objectClass=oathToken)(aeStatus=0)(!(oathHOTPCounter=*)))"
  attrs=oathSecret
    by self =a
    by * auth

# last-catch: no access to oathSecret from here
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=oathSecret
    by * none

# Limit proxy authorization by granting access to 'authzTo'
# Ensure that no other entity has =x privilege!
#---------------------------------------------------------------------------

access to
  dn.onelevel="cn=ae,{{ aedir_suffix }}"
  attrs=authzTo
  filter="(&(objectClass=aeService)(aeStatus=0)(memberOf=cn=ae-login-proxies,cn=ae,{{ aedir_suffix }}))"
    by self read
    by * none break

access to
  dn.onelevel="cn=ae,{{ aedir_suffix }}"
  attrs=authzTo
  filter="(&(objectClass=aeService)(aeStatus=0))"
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" =csrw
    by * none break

access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=authzTo,authzFrom
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" =csrz
    by group/aeGroup/member="cn=ae-auditors,cn=ae,{{ aedir_suffix }}" =csr
    by * none

#---------------------------------------------------------------------------
# General ACLs
# This MUST be below ACLs for password attrs!
#---------------------------------------------------------------------------

# Global first-catch ACLs which fire no matter what else happens afterwards...
# AE admins can manage everything else, AE auditors can read everything else
access to
  dn.subtree="{{ aedir_suffix }}"
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" manage
    by group/aeGroup/member="cn=ae-auditors,cn=ae,{{ aedir_suffix }}" read
    by * none break

# Block access to archived entries from here no matter what
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(aeStatus=2)"
    by * none

## block cross-zone access to zone 'ae'
#access to
#  dn.subtree="cn=ae,{{ aedir_suffix }}"
#    by dn.subtree="cn=ae,{{ aedir_suffix }}" none break
#    by * auth

# Public defaults
#------------------------------------------------------------------

access to
  dn.subtree="cn=pub,{{ aedir_suffix }}"
  attrs=entry,entryDN,entryUUID,children,objectClass,hasSubordinates,modifyTimestamp,cn,description,@namedObject,@posixGroup,@sudoRole,@DUAConfigProfile,@pkiCA
    by users read

#------------------------------------------------------------------
# OATH-LDAP access control
#------------------------------------------------------------------

# grant read access to password policy DN in oathUser entries to OTP validator
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=oathUser)"
  attrs=pwdPolicySubentry
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" read
    by * none break

# manage access to attribute 'pwdFailureTime' for OTP validator
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=oathUser)"
  attrs=pwdFailureTime
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" manage
    by * none break

# An active but uninitialized OATH token device can
# itself set but not read new oathTokenPIN value
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(&(objectClass=oathToken)(aeStatus=0)(!(oathHOTPCounter=*)))"
  attrs=oathTokenPIN
    by self =w
    by * none break

# FIX ME! (concept for recovering token PIN needed)
# No other access to oathTokenPIN from here
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=oathTokenPIN
    by * none

# An active but uninitialized OATH token device can itself
# read someother attributes during enrollment
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(&(objectClass=oathToken)(aeStatus=0)(!(oathHOTPCounter=*)))"
  attrs=entry,objectClass,serialNumber,oathHOTPParams,oathTokenIdentifier
    by self read
    by * none break

# read access for devices to some attributes in the associated policy entries
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(&(objectClass=oathHOTPParams)(aeStatus=0))"
  attrs=entry,objectClass,cn,oathHMACAlgorithm,oathOTPLength,oathEncKey
    by set="user/oathHOTPParams & this" read
    by * none break

# read access for devices to some attributes in the associated policy entries
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(&(objectClass=oathTOTPParams)(aeStatus=0))"
  attrs=entry,objectClass,cn,oathHMACAlgorithm,oathOTPLength,oathEncKey
    by set="user/oathTOTPParams & this" read
    by * none break

# Access to read all OATH parameter entries for
# 1. OTP validator
# 2. user entries referencing a token controlled by this
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=oathParams)"
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" read
    by set="user/objectClass & [aeUser]" read
    by set="user/oathHOTPToken/oathHOTPParams & this" read
    by set="user/oathTOTPToken/oathTOTPParams & this" read
    by * none

# write access to special status attributes for OTP validator
access to
  dn.onelevel="cn=otp,{{ aedir_suffix }}"
  filter="(objectClass=oathToken)"
  attrs=oathLastLogin,oathFailureCount,oathLastFailure
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" write
    by set="user & this/-1/aeZoneAdmins/member" =rz
    by * none break

# oathHOTPCounter in token entries
#---------------------------------------------------------------------------

# An active but uninitialized OATH token device can
# itself reset the oathHOTPCounter value to zero
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(&(objectClass=oathToken)(aeStatus=0)(!(oathHOTPCounter=*)))"
  attrs=oathHOTPCounter
  val/integerMatch="0"
    by self =a
    by * none break

# 'oathHOTPCounter' in token entries can be
# 1. read and written by validation service
# 2. read and deleted by zone admins
# 3. read by associated users
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(&(objectClass=oathToken)(aeStatus=0))"
  attrs=oathHOTPCounter
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" write
    by dn.base="uid=ae-dir-otpenroll,cn=ae,{{ aedir_suffix }}" read
    by set="user & this/-1/aeZoneAdmins/member" =rz
    by set="user & this/-1/aeZoneAuditors/member" read
    by set="user/oathHOTPToken & this" read
    by * none

# Token entries must be read by OTP validator
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=oathToken)"
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" read
    by * none break

#------------------------------------------------------------------
# Delegated administration of active zones
#------------------------------------------------------------------

# Zone admins can add child entries
access to
  filter="(&(objectClass=aeZone)(aeStatus=0))"
  attrs=children
    by set="user & this/aeZoneAdmins/member" write
    by set="user & this/aeZoneAuditors/member" read
    by set="user/-1 & this" search
    by * none
# some zone attributes readable for bound entitities in that zone
access to
  filter="(&(objectClass=aeZone)(aeStatus=0))"
  attrs=entry,cn,description,objectClass
    by set="user & this/aeZoneAdmins/member" read
    by set="user & this/aeZoneAuditors/member" read
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" read
    by set="user/-1 & this" read
    by users search
    by * none
# rest of zone attributes only readable for zone admins/auditors
access to
  filter="(&(objectClass=aeZone)(aeStatus=0))"
  attrs=aeZoneAdmins
    by set="user & this/aeZoneAdmins/member" read
    by set="user & this/aeZoneAuditors/member" read
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" read
    by * none
# rest of zone attributes only readable for zone admins/auditors
access to
  filter="(&(objectClass=aeZone)(aeStatus=0))"
    by set="user & this/aeZoneAdmins/member" read
    by set="user & this/aeZoneAuditors/member" read
    by * none

# aeSudoRule entries
access to
  dn.regex="^cn=({{ aedir_aesudorule_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeSudoRule)"
    by set="user & this/-1/aeZoneAdmins/member" write
    by set="user & this/-1/aeZoneAuditors/member" read
    by * none break

# aeGroup entries add-only attributes
access to
  dn.regex="^cn=({{ aedir_aegroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeGroup)"
  attrs=objectClass,entry,cn,gidNumber
    by set="user & this/-1/aeZoneAdmins/member" =arscxd
    by set="user & this/-1/aeZoneAuditors/member" read
    by * none break
# aeGroup entries
access to
  dn.regex="^cn=({{ aedir_aegroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeGroup)"
    by set="user & this/-1/aeZoneAdmins/member" write
    by set="user & this/-1/aeZoneAuditors/member" read
    by * none break

# aeUser entries add-only attributes
access to
  dn.regex="^uid=({{ aedir_aeuser_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeUser)"
  attrs=objectClass,entry,uid,uidNumber,aePerson
    by set="user & this/-1/aeZoneAdmins/member" =arscxd
    by set="user & this/-1/aeZoneAuditors/member" read
    by * none break
# block write access for zone admins to some attributes assumed to have NO-USER-MODIFICATION
access to
  dn.regex="^uid=({{ aedir_aeuser_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeUser)"
  attrs=memberOf
    by set="user & this/-1/aeZoneAdmins/member" read
    by * none break
# aeUser entries not archived
access to
  dn.regex="^uid=({{ aedir_aeuser_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeUser)"
  attrs=!msPwdResetObject
    by set="user & this/-1/aeZoneAdmins/member" write
    by set="user & this/-1/aeZoneAuditors/member" read
    by * none break

# aeService entries add-only attributes
access to
  dn.regex="^uid=({{ aedir_aeservice_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeService)"
  attrs=objectClass,entry,uid,uidNumber
    by set="user & this/-1/aeZoneAdmins/member" =arscxd
    by set="user & this/-1/aeZoneAuditors/member" read
    by * none break
# block write access for zone admins to some attributes assumed to have NO-USER-MODIFICATION
access to
  dn.regex="^uid=({{ aedir_aeservice_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeService)"
  attrs=memberOf
    by set="user & this/-1/aeZoneAdmins/member" read
    by * none break
# aeService entries
access to
  dn.regex="^uid=({{ aedir_aeservice_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeService)"
    by set="user & this/-1/aeZoneAdmins/member" write
    by set="user & this/-1/aeZoneAuditors/member" read
    by * none break

# aeSrvGroup entries
access to
  dn.regex="^cn=({{ aedir_aesrvgroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeSrvGroup)"
  attrs=children
    by set="user & this/-1/aeZoneAdmins/member" write
    by set="user & this/aeSetupGroups/member" write
    by set="user & this/aeSrvGroup/aeSetupGroups/member" read
    by set="user & this/-1/aeZoneAuditors/member" read
    by * none break
access to
  dn.regex="^cn=({{ aedir_aesrvgroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeSrvGroup)"
    by set="user & this/-1/aeZoneAdmins/member" write
    by set="user & this/-1/aeZoneAuditors/member" read
    by set="user & this/aeSetupGroups/member" read
    by * none break

# aeHost entries have to be subordinate entries of aeSrvGroup entries
access to
  dn.regex="^host=([a-z]?[a-z0-9.-]+),cn=({{ aedir_aesrvgroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeHost)"
    by set="user & this/-2/aeZoneAdmins/member" write
    by set="user & this/-1/aeSetupGroups/member" write
    by set="user & this/aeSrvGroup/aeSetupGroups/member" read
    by set="user & this/-2/aeZoneAuditors/member" read
    by * none break

# aeNwDevice entries have to be subordinate entries of aeHost entries
access to
  dn.regex="^cn=.+,host=([a-z]?[a-z0-9.-]+),cn=({{ aedir_aesrvgroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeNwDevice)"
    by set="user & this/-3/aeZoneAdmins/member" write
    by set="user & this/-2/aeSetupGroups/member" write
    by set="user & this/-2/aeSrvGroup/aeSetupGroups/member" read
    by set="user & this/-1" read
    by set="user & this/-3/aeZoneAuditors/member" read
    by * none break

# aeService entries can also be subordinate entries of aeSrvGroup
# entries if they need read access to aeUser and aeGroup entries
# aeService entries add-only attributes
access to
  dn.regex="^uid=({{ aedir_aeservice_uid_regex }}),cn=({{ aedir_aesrvgroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeService)"
  attrs=objectClass,entry,uid,uidNumber
    by set="user & this/-2/aeZoneAdmins/member" =arscxd
    by set="user & this/-1/aeSetupGroups/member" =arscxd
    by set="user & this/aeSrvGroup/aeSetupGroups/member" read
    by set="user & this/-2/aeZoneAuditors/member" read
    by * none break
# aeService entries
access to
  dn.regex="^uid=({{ aedir_aeservice_uid_regex }}),cn=({{ aedir_aesrvgroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeService)"
    by set="user & this/-2/aeZoneAdmins/member" write
    by set="user & this/-1/aeSetupGroups/member" write
    by set="user & this/aeSrvGroup/aeSetupGroups/member" read
    by set="user & this/-2/aeZoneAuditors/member" read
    by * none break

# aeTag entries
access to
  dn.regex="^cn=({{ aedir_aetag_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeTag)"
    by set="user & this/-1/aeZoneAdmins/member" write
    by set="user & this/-1/aeZoneAuditors/member" read
    by * none break

# aeAuthcToken entries
access to
  dn.regex="^serialNumber=({{ aedir_aeauthctoken_serial_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeAuthcToken)"
    by set="user & this/-1/aeZoneAdmins/member" write
    by set="user & this/-1/aeZoneAuditors/member" read
    by set="user/oathHOTPToken & this" read
    by set="user/oathTOTPToken & this" read
    by group/aeGroup/member="cn=ae-all-zone-admins,cn=ae,{{ aedir_suffix }}" read
    by * none break

# aeContact entries
access to
  dn.regex="^(cn|mail)=[^,]+,cn={{ aedir_aezone_cn_regex }},{{ aedir_suffix }}$"
  filter="(objectClass=aeContact)"
    by set="user & this/-1/aeZoneAdmins/member" write
    by set="user & this/-1/aeZoneAuditors/member" read
    by * none break

# aeMailGroup entries
access to
  dn.regex="^cn=({{ aedir_aegroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeMailGroup)"
    by set="user & this/-1/aeZoneAdmins/member" write
    by set="user & this/-1/aeZoneAuditors/member" read
    by * none break

# Organizational entries (departments, locations and persons)
#------------------------------------------------------------------

# administration of aePerson entries
access to
  dn.regex="^uniqueIdentifier=({{ aedir_aeperson_uniqueid_regex }}),cn={{ aedir_aezone_cn_regex }},{{ aedir_suffix }}$"
  filter="(objectClass=aePerson)"
    by set="user & this/-1/aeZoneAdmins/member" write
    by set="user & this/-1/aeZoneAuditors/member" read
    by * none break
# administration and readability of aeLocation entries
access to
  dn.regex="^cn=({{ aedir_aelocation_cn_regex }}),cn={{ aedir_aezone_cn_regex }},{{ aedir_suffix }}$"
  filter="(objectClass=aeLocation)"
    by set="user & this/-1/aeZoneAdmins/member" write
    by set="user & this/-1/aeZoneAuditors/member" read
    by group/aeGroup/member="cn=ae-all-zone-admins,cn=ae,{{ aedir_suffix }}" read
    by set="user/aePerson/aeLocation & this" read
    by * none break
# administration and readability of aeDept entries
access to
  dn.regex="^departmentNumber=({{ aedir_aedept_deptnumber_regex }}),cn={{ aedir_aezone_cn_regex }},{{ aedir_suffix }}$"
  filter="(objectClass=aeDept)"
    by set="user & this/-1/aeZoneAdmins/member" write
    by set="user & this/-1/aeZoneAuditors/member" read
    by group/aeGroup/member="cn=ae-all-zone-admins,cn=ae,{{ aedir_suffix }}" read
    by set="user/aePerson/aeDept & this" read
    by * none break

#---------------------------------------------------------------------------
# Inactive entries not visible to normal users/systems from here
#---------------------------------------------------------------------------

access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(&(aeStatus=*)(!(aeStatus=0)))"
    by * none

# Password reset for active users
#------------------------------------------------------------------

# Access to objectClass value "msPwdResetObject"
# 1. write access for password self-service application
# 2. read access for the user (self)
access to
  dn.regex="^uid=({{ aedir_aeuser_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  attrs=objectClass
  filter="(objectClass=aeUser)"
  val=msPwdResetObject
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" write
    by self read
    by * none

# Access to aeTag value "pub-tag-no-welcome-yet"
# 1. write access for password self-service application
# 2. read access for the user (self)
access to
  dn.regex="^uid=({{ aedir_aeuser_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  attrs=aeTag
  filter="(objectClass=aeUser)"
  val=pub-tag-no-welcome-yet
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" write
    by self read
    by * none

# Restricted access to msPwdReset* password/credential attributes:
# 1. write-only access for password self-service application
# 2. read access for zone admins
access to
  dn.regex="^uid=({{ aedir_aeuser_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeUser)"
  attrs=msPwdResetPasswordHash
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" =w
    by * none
access to
  dn.regex="^uid=({{ aedir_aeuser_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeUser)"
  attrs=msPwdResetAdminPw
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" =w
    by set="user & this/-1/aeZoneAdmins/member" read
    by * none

# Access to rest of msPwdReset* attributes
access to
  dn.regex="^uid=({{ aedir_aeuser_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeUser)"
  attrs=@msPwdResetObject
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" write
    by set="user & this/-1/aeZoneAdmins/member" read
    by set="user & this/-1/aeZoneAuditors/member" read
    by self read
    by * none

# Allow read access on necessary attributes
access to
  filter="(objectClass=aeUser)"
  attrs=entry,uid,aeStatus,objectClass,mail,pwdPolicySubentry,pwdChangedTime,aeTag,cn,displayName,description,entryCSN,creatorsName,createTimestamp,modifiersName,modifyTimestamp,memberOf,aeRemoteHost
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" read
    by * none break

# Allow search access to memberOf for special services
access to
  filter="(objectClass=aeUser)"
  attrs=memberOf
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" search
    by * none break

# Self-service attributes of active users
#------------------------------------------------------------------

# users can edit the description describing purpose of own account
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aeUser)"
  attrs=description
    by self write
    by * none break

{% if aedir_sshpublickey_self_filter %}
# users can maintain own sshPublicKey attribute
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="{{ aedir_sshpublickey_self_filter }}"
  attrs=sshPublicKey
    by self write
    by * none break
{% endif %}

{% include 'service_access.conf.j2' %}

# Last catch ACLs
#------------------------------------------------------------------

# groups ae-all-zone-admins and ae-all-zone-auditors must be excluded after this!
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(&(objectClass=aeGroup)(cn=ae-all-zone-*))"
    by * none
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=memberOf
  val.exact="cn=ae-all-zone-admins,cn=ae,{{ aedir_suffix }}"
    by * none
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=memberOf
  val.exact="cn=ae-all-zone-auditors,cn=ae,{{ aedir_suffix }}"
    by * none

# Read access for all active group members
# Notes:
# - aeService as member must not see the groups!
# - the groups ae-all-zone-admins and ae-all-zone-auditors must be excluded!
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aeGroup)"
    by set="user & ([ldap:///] + user + [?entryDN?base?(&(objectClass=aeUser)(memberOf=] + this + [)(aeStatus=0))])/entryDN" read
    by * auth

# Read access to aeUser and aeService entries for all aeUser members
# in at least one same group(s)
# Notes:
# - aeService as member must not see the users!
# - the groups ae-all-zone-admins and ae-all-zone-auditors must be excluded!
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(|(objectClass=aeUser)(objectClass=aeService))"
    by self read
    by set="this/memberOf & ( [ldap:///] + user + [?memberOf?base?(&(objectClass=aeUser)(aeStatus=0))])/memberOf" read
    by * auth

# ID pool attributes
#------------------------------------------------------------------

# write access to next UID/GID counter for all zone admins
access to
  dn.base="{{ aedir_suffix }}"
  attrs=uidNumber,gidNumber
    by group/aeGroup/member="cn=ae-all-zone-admins,cn=ae,{{ aedir_suffix }}" write
    by * none

# read access to the POSIX ID ranges for all active aeUser entries
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=@aePosixIdRanges
    by group/aeGroup/member="cn=ae-all-zone-admins,cn=ae,{{ aedir_suffix }}" read
    by group/aeGroup/member="cn=ae-all-zone-auditors,cn=ae,{{ aedir_suffix }}" read
    by * none

# Password policy entries
#------------------------------------------------------------------

# Read access for
# 1. Password self-service application
# 2. all zone admins/auditors
# 3. all active aeUser entries
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=pwdPolicy)"
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" read
    by group/aeGroup/member="cn=ae-all-zone-admins,cn=ae,{{ aedir_suffix }}" read
    by group/aeGroup/member="cn=ae-all-zone-auditors,cn=ae,{{ aedir_suffix }}" read
    by set="user & ([ldap:///] + user + [?entryDN?base?(&(objectClass=aeUser)(aeStatus=0))])/entryDN" read
    by * auth

# Read-only (but no administrative) access to active aePerson entries
#---------------------------------------------------------------------------

# Give read access to confidential HR attributes only to
# personal user accounts referencing the person entry
# (access for zone admins/auditors is granted above)
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aePerson)"
  attrs={{ aedir_confidential_person_attrs|join(',') }}
    by set="user/aePerson & this" read
    by * none

# Give read access to other attributes to:
# - personal user accounts referencing the person entry
# - all zone admins
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aePerson)"
    by set="user/aePerson & this" read
    by group/aeGroup/member="cn=ae-all-zone-admins,cn=ae,{{ aedir_suffix }}" read
    by * none break

{% if aedir_addressbook_attrs %}
# restricted addressbook read access to person entries for
# members of groups referenced as address book user groups in the zone
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(|(objectClass=aeContact)(objectClass=aePerson)(objectClass=aeMailGroup))"
  attrs=entry,{{ aedir_addressbook_attrs|join(',') }}
    by set="user & this/-1/aeABAccessGroups/member" read
    by * none
{% endif %}

# active zone admins are granted to access the accesslog DB
# (for web2ldap [Audit] links)
#------------------------------------------------------------------

access to
  dn.base="{{ aedir_suffix }}"
  attrs=auditContext
    by group/aeGroup/member="cn=ae-all-zone-admins,cn=ae,{{ aedir_suffix }}" read
    by * none

access to
  dn.base="{{ aedir_suffix }}"
  attrs=children,objectClass,ou,description
    by users read
    by * auth

access to
  dn.subtree="{{ aedir_suffix }}"
    by users search
    by * auth

#---------------------------------------------------------------------------
# overlays used within {{ aedir_suffix }}
#---------------------------------------------------------------------------

# for counting search results without retrieving them
overlay noopsrch

# for dereferencing attributes
overlay deref

# for server-side sorting
overlay sssvlv

# Check sub-tree wide uniqueness of certain attributes
overlay unique
unique_uri "ldap:///{{ aedir_suffix }}?uid,uidNumber?sub?(objectClass=*)"
unique_uri "ldap:///{{ aedir_suffix }}?nickName?sub?(objectClass=*)"
unique_uri "ldap:///{{ aedir_suffix }}?mailLocalAddress?sub?(objectClass=*)"
unique_uri "ldap:///{{ aedir_suffix }}?seeAlso?sub?(objectClass=*)"
unique_uri "ldap:///{{ aedir_suffix }}?ipHostNumber,host,aeFqdn,macAddress?sub?(objectClass=*)"
unique_uri "ldap:///{{ aedir_suffix }}?employeeNumber,uniqueIdentifier,displayName?sub"
{% if aedir_unique_person_zones %}
# only one aeUser entry per aePerson in these zones
{% for zone in aedir_unique_person_zones %}
unique_uri "ldap:///cn={{ zone }},{{ aedir_suffix }}?aePerson?sub"
{% endfor %}
{% endif %}
# these two constraints are only possible with a negation filter
unique_uri "ldap:///{{ aedir_suffix }}?cn?sub?(!(|(objectClass=aePerson)(objectClass=aeUser)(objectClass=aeNwDevice)))"
unique_uri "ldap:///{{ aedir_suffix }}?gidNumber?sub"
unique_uri "ldap:///{{ aedir_suffix }}?serialNumber?sub?(objectClass=*)"

# Enforce constraints on attribute values
overlay constraint

constraint_attribute aeStatus
  regex "^(-1|0|1|2)$"

constraint_attribute aeExpiryStatus
  regex "^(1|2)$"

# Limit some attributes to be SINGLE-VALUE by constraint
constraint_attribute uid
  count 1
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeObject)"
constraint_attribute cn
  count 1
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeObject)"
constraint_attribute mail
  count 1
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=inetLocalMailRecipient)"
constraint_attribute authzTo
  count 1

constraint_attribute loginShell
  set "this/loginShell & ( [{{ aedir_login_shells|join("] | [") }}] )"

constraint_attribute host
  regex "^[a-zA-Z0-9.-]+$"

constraint_attribute uniqueIdentifier
  regex "^{{ aedir_aeperson_uniqueid_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aePerson)"

constraint_attribute cn
  regex "^{{ aedir_aelocation_cn_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeLocation)"

constraint_attribute departmentNumber
  regex "^{{ aedir_aedept_deptnumber_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeDept)"

constraint_attribute uid
  regex "^{{ aedir_aeuser_uid_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"
constraint_attribute uid
  regex "^{{ aedir_aeservice_uid_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeService)"

# Regex constraint on 'cn' in zone entries
constraint_attribute cn
  regex "^{{ aedir_aezone_cn_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeZone)"

# check whether uidNumber is within valid range (see aeRoot)
constraint_attribute uidNumber
  set "([{{ aedir_suffix }}] & ([ldap:///{{ aedir_suffix }}?entryDN?base?(&(objectClass=aeRoot)(aeUidNumberMin<=]+this/uidNumber+[)(aeUidNumberMax>=]+this/uidNumber+[))])/entryDN)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(!(&(objectClass=aeService)(entryDN:dnOneLevelMatch:=cn=ae,{{ aedir_suffix }})))"

# check whether gidNumber is within valid range (see aeRoot)
constraint_attribute gidNumber
  set "([{{ aedir_suffix }}] & ([ldap:///{{ aedir_suffix }}?entryDN?base?(&(objectClass=aeRoot)(aeGidNumberMin<=]+this/gidNumber+[)(aeGidNumberMax>=]+this/gidNumber+[))])/entryDN)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(!(&(objectClass=aeService)(entryDN:dnOneLevelMatch:=cn=ae,{{ aedir_suffix }})))"

# uidNumber and gidNumber in posixAccount entries must be the same value
constraint_attribute uidNumber,gidNumber
  set "this/uidNumber & this/gidNumber"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=posixAccount)"

# naming convention for 'cn' in 'aeSrvGroup' entries
constraint_attribute cn
  regex "^{{ aedir_aesrvgroup_cn_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeSrvGroup)"

# naming convention for 'cn' in 'aeGroup' entries
constraint_attribute cn
  regex "^{{ aedir_aegroup_cn_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeGroup)"

# naming convention for 'cn' in 'aeSudoRule' entries
constraint_attribute cn
  regex "^{{ aedir_aesudorule_cn_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeSudoRule)"

# visibility of aeSudoRule entries is maintained for 'aeSrvGroup'
# => limit sudoHost to 'ALL'
constraint_attribute sudoHost
  regex "^ALL$"

# attribute 'mobile'
constraint_attribute mobile
  regex "^\\+[1-9]?[0-9 -]+$"

# naming convention for 'aeTicketId'
constraint_attribute aeTicketId
  regex "^{{ aeticketid_regex }}$"

constraint_attribute sshPublicKey
  regex "^{{ aedir_aeservice_sshpubkey_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeService)"
constraint_attribute sshPublicKey
  regex "^{{ aedir_aeuser_sshpubkey_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"

# zone (password) admin/auditor groups to DNs of active aeGroup entries
# must solely reference special zone role groups
constraint_attribute aeZoneAdmins
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeGroup)(aeStatus=0)(cn=*-zone-admins)(!(|(cn:dn:=ae)(cn:dn:=pub))))"
constraint_attribute aePasswordAdmins
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeGroup)(aeStatus=0)(cn=*-zone-admins)(!(|(cn:dn:=ae)(cn:dn:=pub))))"
# aePasswordAdmins must be subset of aeZoneAdmins
constraint_attribute aePasswordAdmins
  set "this/aePasswordAdmins & this/aeZoneAdmins"
  restrict="ldap:///{{ aedir_suffix }}??sub"
constraint_attribute aeZoneAuditors
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeGroup)(aeStatus=0)(|(cn=*-zone-admins)(cn=*-zone-auditors))(!(|(cn:dn:=ae)(cn:dn:=pub))))"

# rights groups to DNs of active aeGroup entries
# must not reference special role groups
constraint_attribute aeLoginGroups,aeSetupGroups,aeLogStoreGroups,aeABAccessGroups
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeGroup)(aeStatus=0)(!(|(cn:dn:=ae)(cn:dn:=pub)(cn=*-zone-admins)(cn=*-zone-auditors))))"
  restrict="ldap:///{{ aedir_suffix }}??sub?(!(cn:dn:=ae))"

# visibility groups to DNs of active aeGroup entries
# must not reference special role groups
constraint_attribute aeVisibleGroups,aeDisplayNameGroups
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(|(objectClass=aeGroup)(objectClass=aeMailGroup))(aeStatus=0)(!(|(cn:dn:=ae)(cn:dn:=pub)(cn=*-zone-admins)(cn=*-zone-auditors))))"
  restrict="ldap:///{{ aedir_suffix }}??sub?(!(cn:dn:=ae))"

# special rights groups constraints for zone ae
constraint_attribute aeLoginGroups,aeSetupGroups,aeLogStoreGroups,aeVisibleGroups,aeDisplayNameGroups
  uri "ldap:///cn=ae,{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeGroup)(aeStatus=0)(!(|(cn=ae-admins)(cn=ae-auditors)(cn=ae-providers)(cn=ae-replicas)(cn=ae-login-proxies)(cn=*-zone-admins)(cn=*-zone-auditors))))"
  restrict="ldap:///cn=ae,{{ aedir_suffix }}??sub"

# rights groups must be referenced in aeVisibleGroups
constraint_attribute aeDisplayNameGroups
  set "this/aeDisplayNameGroups & this/aeVisibleGroups"
  restrict="ldap:///{{ aedir_suffix }}??sub"
constraint_attribute aeLoginGroups
  set "this/aeLoginGroups & this/aeVisibleGroups"
  restrict="ldap:///{{ aedir_suffix }}??sub"

# restrict values of aeVisibleSudoers to DNs of active aeSudoRule entries
constraint_attribute aeVisibleSudoers
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeSudoRule)(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub"

# restrict references from personal user accounts to their person entries
constraint_attribute aePerson
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(objectClass=aePerson)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"
# if parent aeZone entry has aeLocation set then it must match aeLocation in aePerson
constraint_attribute aePerson,entryDN
  set "this/-1/entryDN & ([ldap:///] + this/-1/entryDN + [?entryDN?base?(&(objectClass=aeZone)(|(!(aeLocation=*))(aeLocation=] + this/aePerson/aeLocation + [)))])/entryDN"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"
# if parent aeZone entry has aeDept set then it must match aeDept in aePerson
constraint_attribute aePerson,entryDN
  set "this/-1/entryDN & ([ldap:///] + this/-1/entryDN + [?entryDN?base?(&(objectClass=aeZone)(|(!(aeDept=*))(aeDept=] + this/aePerson/aeDept + [)))])/entryDN"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"

# restrict tag references
constraint_attribute aeTag
  uri "ldap:///{{ aedir_suffix }}?cn?sub?(&(objectClass=aeTag)(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub?"

# restrict aeProxyFor in aeSrvGroup entry to reference solely active non-proxy aeSrvGroup in same zone
constraint_attribute aeProxyFor
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeSrvGroup)(aeStatus=0)(!(aeProxyFor=*)))"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeSrvGroup)"
constraint_attribute aeProxyFor,entryDN
  set "this/aeProxyFor/-1 & this/-1"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeSrvGroup)"

# restrict aeRequires in aeSrvGroup entry to reference solely active aeSrvGroup
constraint_attribute aeRequires
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeSrvGroup)(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeSrvGroup)"

# restrict aeSrvGroup in aeHost and aeService entries to reference solely active aeSrvGroup in same zone
constraint_attribute aeSrvGroup
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeSrvGroup)(aeStatus=0)(!(aeProxyFor=*)))"
  restrict="ldap:///{{ aedir_suffix }}??sub?(|(objectClass=aeHost)(objectClass=aeService))"
constraint_attribute aeSrvGroup
  set "this/aeSrvGroup/-1 & this/-2"
  restrict="ldap:///{{ aedir_suffix }}??sub?(|(objectClass=aeHost)(objectClass=aeService))"

# restrict aeNwDevice in aeNwDevice entry to reference
# an active aeNwDevice in same aeHost but not itself
constraint_attribute aeNwDevice
  set "this/aeNwDevice & ([ldap:///]+this/aeNwDevice+[?entryDN?base?(&(objectClass=aeNwDevice)(aeStatus=0)(!(cn=]+this/cn+[)))])/entryDN"
constraint_attribute aeNwDevice
  set "this/aeNwDevice/-1 & this/-1"

# restrict aeHost in aeService entry to reference solely active aeHost entry
constraint_attribute aeHost
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeHost)(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeService)"

# Force 'mail' in non-mailbox personal user accounts to match
# 'mail' in referenced person entry
constraint_attribute aePerson,mail
  set "this/aePerson/mail & this/mail"
  restrict="ldap:///{{ aedir_suffix }}??sub?(&(objectClass=aeUser)(!(objectClass=inetLocalMailRecipient)))"

# Force 'mail' in mailbox-related personal user accounts to match
# one of the 'mailLocalAddress' attribute values
constraint_attribute aePerson,mail
  set "this/mail & this/mailLocalAddress"
  restrict="ldap:///{{ aedir_suffix }}??sub?(&(objectClass=aeUser)(objectClass=inetLocalMailRecipient))"

# 'givenName' the same in personal user accounts and referenced person entries
constraint_attribute aePerson,givenName
  set "this/aePerson/givenName & this/givenName"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"

# 'sn' the same in personal user accounts and referenced person entries
constraint_attribute aePerson,sn
  set "this/aePerson/sn & this/sn"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"

# 'sudoUser' only may contain a reference to 'cn' of an active group
constraint_attribute sudoUser
  set "([%] + [ldap:///{{ aedir_suffix }}??sub?(&(objectClass=aeGroup)(aeStatus=0)(!(|(cn=ae-admins)(cn=ae-auditors)(cn=ae-provider)(cn=ae-replicas)(cn=ae-login-proxies)(cn=*-zone-admins)(cn=*-zone-auditors))))]/cn) & this/sudoUser"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeSudoRule)"

# 'homeDirectory' must be either
# 1. composed as /<path-prefix>/<uid> for 'aeUser' entries
#    with valid path-prefix {{ aedir_homedirectory_prefixes|join(' or ') }}
# 2. just set to value "{{ aedir_homedirectory_hidden }}"
constraint_attribute uid,homeDirectory
  set "( [{{ aedir_homedirectory_prefixes|join('] | [') }}] + [/] + this/uid | [{{ aedir_homedirectory_hidden }}] ) & this/homeDirectory"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"

# displayName in personal user account must be composed based on "<cn> (<uid>/<uidNumber>)"
constraint_attribute displayName,cn,uid,uidNumber
  set "(this/cn + [ (] + this/uid + [/] + this/uidNumber + [)]) & this/displayName"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"

# cn in aeUser or aePerson entry must be composed based on "<givenName> <sn>"
constraint_attribute cn,sn,givenName
  set "(this/givenName + [ ] + this/sn) & this/cn"
  restrict="ldap:///{{ aedir_suffix }}??sub?(|(objectClass=aePerson)(objectClass=aeUser))"

# restrict member zone(s) to active zones
constraint_attribute aeMemberZone
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeZone)(aeStatus=0))"

# restrict references from user groups to have only active accounts as members
constraint_attribute member
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(|(objectClass=aeUser)(objectClass=aeService))(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeGroup)"

# restrict references from mail groups to have only active accounts/contacts with e-mail address as members
constraint_attribute member
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(|(objectClass=inetLocalMailRecipient)(objectClass=aeContact))(mail=*)(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeMailGroup)"

# zone-constrainted groups must contain only members from specific zone
constraint_attribute member
  set "this/member/-1 & this/aeMemberZone"
  restrict="ldap:///{{ aedir_suffix }}??sub?(&(objectClass=groupOfEntries)(aeMemberZone=*))"

# location-constrainted groups must contain only aeUser members assigned to a specific location
constraint_attribute member
  set "this/member/aePerson/aeLocation & this/aeLocation"
  restrict="ldap:///{{ aedir_suffix }}??sub?(&(objectClass=groupOfEntries)(aeLocation=*))"

# department-constrainted groups must contain only aeUser members assigned to a specific department
constraint_attribute member
  set "this/member/aePerson/aeDept & this/aeDept"
  restrict="ldap:///{{ aedir_suffix }}??sub?(&(objectClass=groupOfEntries)(aeDept=*))"

# restrict memberUid to be uid of an active posixAccount
constraint_attribute memberUid
  uri "ldap:///{{ aedir_suffix }}?uid?sub?(&(|(objectClass=aeUser)(objectClass=aeService))(objectClass=posixAccount)(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub"

# restrict memberUid to be consistent with group membership defined in member
constraint_attribute memberUid,member
  set "this/memberUid & this/member/uid"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=posixGroup)"

# restrict rfc822MailMember to be mail of an active local e-mail account
constraint_attribute rfc822MailMember
  uri "ldap:///{{ aedir_suffix }}?mail?sub?(&(|(objectClass=inetLocalMailRecipient)(objectClass=aeContact))(mail=*)(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub"

# restrict rfc822MailMember to be consistent with group membership defined in member
constraint_attribute rfc822MailMember,member
  set "this/rfc822MailMember & this/member/mail"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeMailGroup)"

# regex constraint for 'serialNumber in aeAuthcToken entries
constraint_attribute serialNumber
  regex "^{{ aedir_aeauthctoken_serial_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeAuthcToken)"

# constraints for aeAuthcToken/oathHOTPToken entries for Yubikey
# aeHwSerialNumber limited to max. eight digits
constraint_attribute aeHwSerialNumber
  regex "^[0-9]{0,8}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(&(objectClass=aeAuthcToken)(objectClass=oathHOTPToken)(cn=yubikey-*))"
constraint_attribute serialNumber,cn,aeHwSerialNumber
  set "this/serialNumber & ([yubikey-] + this/aeHwSerialNumber)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(&(objectClass=aeAuthcToken)(objectClass=oathHOTPToken)(cn=yubikey-*))"
constraint_attribute displayName,aeHwSerialNumber
  set "this/displayName & ([yubikey #] + this/aeHwSerialNumber)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(&(objectClass=aeAuthcToken)(objectClass=oathHOTPToken)(cn=yubikey-*))"
constraint_attribute oathTokenSerialNumber,aeHwSerialNumber
  set "this/oathTokenSerialNumber & this/aeHwSerialNumber"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=oathHOTPToken)"
constraint_attribute oathTokenIdentifier
  regex "^ubhe[0-9]{8}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(&(objectClass=aeAuthcToken)(objectClass=oathHOTPToken)(cn=yubikey-*))"

# standard constraints for OATH-LDAP
constraint_attribute oathHOTPToken
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(objectClass=oathHOTPToken)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=oathHOTPUser)"
constraint_attribute oathHOTPParams
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(objectClass=oathHOTPParams)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=oathHOTPToken)"
constraint_attribute oathTOTPToken
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(objectClass=oathTOTPToken)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=oathTOTPUser)"
constraint_attribute oathTOTPParams
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(objectClass=oathTOTPParams)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=oathTOTPToken)"

# aeUser>aePerson and aeAuthcToken>aeOwner entries must reference same aePerson entry
constraint_attribute oathHOTPToken
  set "this/oathHOTPToken/aeOwner & this/aePerson"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=oathHOTPUser)"
constraint_attribute oathTOTPToken
  set "this/oathTOTPToken/aeOwner & this/aePerson"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=oathTOTPUser)"

# authentication tokens shall only be assigned to active owners (persons)
constraint_attribute aeOwner
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aePerson)(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeAuthcToken)"

# check whether appropriate password policy is assigned
# FIX ME! This does not work as expected yet!
#constraint_attribute pwdPolicySubentry
#  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=pwdPolicy)(aeStatus=0))"

# SSH certificate options, see CLI arg -O in man-page ssh-keygen(1)
# only permit values are allowed assuming that
# 1. SSH certs are issued with '-O clear' and
# 2. authorized keys files are generated with 'restrict'
constraint_attribute aeSSHPermissions
  regex "^({{ aedir_sshkey_perms|join('|') }})$"

# Where to log LDAP write operations (for auditing)
overlay accesslog
logdb "{{ aedir_accesslog_suffix }}"
logops writes
logold "(objectClass=*)"
logoldattr entryUUID objectClass cn uid
logpurge {{ openldap_log_purge }}

# Referential integrity checking
overlay refint
refint_attributes
  aeHost
  aeLocation
  aeLoginGroups
  aeLogStoreGroups
  aeNwDevice
  aeOwner
  aePerson
  aeProxyFor
  aeSetupGroups
  aeSrvGroup
  aeVisibleGroups
  aeDisplayNameGroups
  aeVisibleSudoers
  manager
  member
  oathHOTPParams
  oathHOTPToken
  oathTOTPParams
  oathTOTPToken
  seeAlso

# for back-links to group entries in member entries
overlay memberof
memberof-group-oc groupOfEntries
memberof-member-ad member
memberof-memberof-ad memberOf
memberof-dangling ignore
memberof-refint true

{% if oath_ldap_enabled==True %}
# pass bind requests to external listener process receiving the requests
# on Unix Domain socket path {{ oath_ldap_socket_path }}
# (after password policy check in slapo-ppolicy)
overlay sock
extensions binddn peername ssf connid
socketpath {{ oath_ldap_socket_path }}
sockops bind compare
{% if oath_ldap_dn_regex %}
sockdnpat "{{ oath_ldap_dn_regex }}"
{% endif %}
{% endif %}

{% if aedir_pwsync_targeturl is defined %}
# send extended requests to external listener process receiving the requests
# on Unix Domain socket path {{ aedir_pwsync_socket_path }}
# (after password policy check in slapo-ppolicy)
overlay sock
extensions binddn peername ssf connid
socketpath {{ aedir_pwsync_socket_path }}
sockops extended
{% if aedir_pwsync_dn_regex %}
sockdnpat "{{ aedir_pwsync_dn_regex }}"
{% endif %}
{% endif %}

# password policy overlay
# (after bind-DN rewriting with slapo-rwm)
overlay ppolicy
# the default password policy is deliberatly unusable
ppolicy_default cn=ppolicy-default,cn=ae,{{ aedir_suffix }}
ppolicy_hash_cleartext
ppolicy_use_lockout

# Record last bind in user entry
overlay lastbind

{% include 'slapo-rwm.conf.j2' %}

#---------------------------------------------------------------------------
# replication of {{ aedir_suffix }}
#---------------------------------------------------------------------------

# syncrepl-Overlay
overlay syncprov
{% if openldap_db_params.um.syncprov_checkpoint %}
syncprov-checkpoint {{ openldap_db_params.um.syncprov_checkpoint }}
{% endif %}
syncprov-sessionlog {{ openldap_db_params.um.syncprov_sessionlog }}
syncprov-nopresent FALSE
syncprov-reloadhint FALSE

{% if openldap_syncrepl_providers %}
{% for provider_replica in openldap_syncrepl_providers if provider_replica!=inventory_hostname %}
syncrepl rid=0{{ loop.index }}
  provider=ldaps://{{ hostvars[provider_replica].get('openldap_service_fqdn',provider_replica) }}
  type=refreshAndPersist
  network-timeout={{ openldap_syncrepl_network_timeout }}
  timeout={{ openldap_syncrepl_timeout }}
  sizelimit=unlimited
  timelimit=unlimited
  interval=00:00:01:00
  retry="30 +"
  keepalive=240:10:30
  searchbase="{{ aedir_suffix }}"
  filter="(objectClass=*)"
  scope=sub
  schemachecking=on
  bindmethod=sasl
  saslmech=EXTERNAL
  tls_cacert={{ openldap_cacert_pathname }}
  tls_cert={{ openldap_cert_pathname }}
  tls_key={{ openldap_key_pathname }}
  tls_protocol_min={{ openldap_syncrepl_tls_protocol_min }}
  tls_cipher_suite={{ openldap_syncrepl_tls_cipher_suite }}

{% endfor %}
mirrormode true
{% endif %}

{% if aedir_session_suffix %}
{% include 'session.conf.j2' %}
{% endif %}

{% include 'monitor.conf.j2' %}
