#!/usr/bin/python
# -*- coding: utf-8 -*-
"""
Sync the personnel attributes (cn, sn, givenName, mail)
from aePerson to aeUser entries
"""

#-----------------------------------------------------------------------
# Imports
#-----------------------------------------------------------------------

# Modules from Python's standard library
import sys
import os
import time
import logging

# Import python-ldap modules/classes
import ldap
import ldap.sasl
import ldap.modlist
import ldap.resiter
from ldap.ldapobject import ReconnectLDAPObject
from logging.handlers import SysLogHandler

#-----------------------------------------------------------------------
# Constants (configuration)
#-----------------------------------------------------------------------

__version__ = '0.0.1'

# Trace level for python-ldap logs
PYLDAP_TRACELEVEL = 0

# Where to store the last run timestamp
SYNC_STATE_FILENAME = '{{ aedir_rundir }}/aeperson2aeuser.state'

# Number of times connecting to LDAP is tried
LDAP_MAXRETRYCOUNT = 3
LDAP_RETRYDELAY = 10.0

AEDIR_LDAPI_URI = '{{ openldap_ldapi_uri }}'
AEDIR_SEARCHBASE = '{{ aedir_suffix }}'
AEDIR_PERSON_BASE = 'cn=people,'+AEDIR_SEARCHBASE

# Filter to be used to search for aePerson entries
AEDIR_AEPERSON_FILTERSTR = '(objectClass=aePerson)'
# Filter to be used to search for AE-DIR personal accounts
AEDIR_AEUSER_FILTERSTR = '(objectClass=aeUser)'

# List of attributes copied from aePerson to aeUser entries
AEDIR_AEPERSON_ATTRS = [
    'cn',
    'givenName',
    'sn',
    'mail',
    'aeStatus'
]

# Exception class used for catching all exceptions
CatchAllException = Exception

#-----------------------------------------------------------------------
# Classes and functions
#-----------------------------------------------------------------------


def generalized_time(secs):
    """
    Convert seconds since epoch into LDAP syntax GeneralizedTime
    """
    return time.strftime('%Y%m%d%H%M%SZ', time.gmtime(secs))


def delta_filter(
        filterstr,
        last_run_timestr,
        current_time_str,
        delta_attr='modifyTimestamp',
    ):
    """
    If last_run_timestr is non-zero filterstr will be extended
    """
    if not last_run_timestr:
        return filterstr
    return (
    '(&'
    '{filterstr}'
    '({delta_attr}>={last_run_timestr})'
    '(!({delta_attr}>={current_time_str}))'
    ')'
    ).format(
        filterstr=filterstr,
        delta_attr=delta_attr,
        last_run_timestr=last_run_timestr,
        current_time_str=current_time_str,
    )


class LogWrapperFile(object):
    """
    file-like wrapper object around logging handler
    """

    def __init__(self, logger, log_level=logging.DEBUG):
        self._logger = logger
        self._log_level = log_level

    def write(self, msg):
        """
        Write msg to logger
        """
        self._logger.log(self._log_level, msg[:-1])


class MyLDAPObject(ReconnectLDAPObject, ldap.resiter.ResultProcessor):
    """
    own LDAPObject for stream processing of search results
    """
    pass


class SyncProcess(object):
    """
    The sync process
    """

    def __init__(self):
        self.script_name = os.path.basename(sys.argv[0])
        self.logger = self.get_logger()
        self.state_filename = SYNC_STATE_FILENAME
        self.ldap_uri = AEDIR_LDAPI_URI
        self.aeperson_counter = 0
        self.modify_counter = 0
        self.error_counter = 0
        self.deactivate_counter = 0
        self.current_time_str = generalized_time(time.time())

    def get_state(self):
        """
        Read the timestamp of last run from file `sync_state_filename'
        """
        try:
            last_run_timestr = open(self.state_filename, 'rb').read().strip()
        except CatchAllException, err:
            self.logger.warn(
                'Error reading file %s: %s',
                repr(SYNC_STATE_FILENAME),
                str(err)
            )
            last_run_timestr = None
        else:
            self.logger.debug(
                'Read last run timestamp %s from file %s',
                repr(last_run_timestr),
                repr(self.state_filename)
            )
        last_run_timestr = last_run_timestr or None
        if last_run_timestr:
            try:
                time.strptime(last_run_timestr, '%Y%m%d%H%M%SZ')
            except ValueError, err:
                self.logger.warn(
                    'Error parsing timestamp %s: %s',
                    repr(last_run_timestr),
                    str(err)
                )
                last_run_timestr = None
        return last_run_timestr # get_state()

    def set_state(self, current_time_str):
        """
        Write the current state
        """
        try:
            # Write the last run timestamp
            open(self.state_filename, 'wb').write(current_time_str)
        except CatchAllException, err:
            self.logger.warn(
                'Could not write %s: %s',
                repr(SYNC_STATE_FILENAME),
                str(err)
            )
        else:
            self.logger.debug(
                'Wrote %s to %s',
                repr(current_time_str),
                repr(SYNC_STATE_FILENAME)
            )
        return # set_state()

    def get_logger(self):
        """
        Initialize the logger instance
        """
        logger = logging.getLogger(self.script_name)
        my_syslog_formatter = logging.Formatter(
            fmt=self.script_name+' %(levelname)s %(message)s'
        )
        my_syslog_handler = logging.handlers.SysLogHandler(
            address='/dev/log',
            facility=SysLogHandler.LOG_CRON,
        )
        my_syslog_handler.setFormatter(my_syslog_formatter)
        if os.environ.get('DEBUG', 'no').lower() == 'yes':
            my_stream_handler = logging.StreamHandler()
            my_stream_formatter = logging.Formatter(
                fmt='%(asctime)s %(levelname)s %(message)s'
            )
            my_stream_handler.setFormatter(my_stream_formatter)
            logger.addHandler(my_stream_handler)
            logger.setLevel(logging.DEBUG)
        else:
            logger.setLevel(logging.INFO)
        logger.addHandler(my_syslog_handler)
        return logger

    def log_summary(self):
        """
        Log a summary of actions and errors, mainly counters
        """
        self.logger.debug('Found %d aePerson entries', self.aeperson_counter)
        if self.modify_counter:
            self.logger.info(
                'Updated %d AE-DIR entries (%d deactivated).',
                self.modify_counter,
                self.deactivate_counter
            )
        else:
            self.logger.debug('No modifications.')

        if self.error_counter:
            self.logger.error('%d errors.', self.error_counter)

    def target_ldap_conn(self):
        """
        Connect and bind to local AE-DIR
        """
        self.logger.debug(
            'Connecting to %s...',
            repr(AEDIR_LDAPI_URI)
        )
        ldap_conn = MyLDAPObject(
            self.ldap_uri,
            trace_level=PYLDAP_TRACELEVEL,
            trace_file=LogWrapperFile(self.logger),
            retry_max=LDAP_MAXRETRYCOUNT,
            retry_delay=LDAP_RETRYDELAY,
        )
        ldap_conn.sasl_interactive_bind_s('', ldap.sasl.sasl({}, 'EXTERNAL'))
        self.logger.debug(
            'Successfully connected to %s as %s',
            repr(self.ldap_uri),
            repr(ldap_conn.whoami_s())
        )
        return ldap_conn

    def run(self):
        """
        the main worker part
        """

        # Determine current state
        #-----------------------------------------------------------------------

        last_run_timestr = self.get_state()
        self.logger.debug(
            'current_time_str=%s last_run_timestr=%s',
            repr(self.current_time_str),
            repr(last_run_timestr)
        )

        # Connect to local AE-DIR
        #-----------------------------------------------------------------------

        aedir_conn = self.target_ldap_conn()

        # Update aeUser entries
        #-----------------------------------------------------------------------

        aeperson_filterstr = delta_filter(
            AEDIR_AEPERSON_FILTERSTR,
            last_run_timestr,
            self.current_time_str
        )

        self.logger.debug(
            'Searching in %s with filter %s',
            repr(AEDIR_PERSON_BASE),
            repr(aeperson_filterstr)
        )
        msg_id = aedir_conn.search(
            AEDIR_PERSON_BASE,
            ldap.SCOPE_ONELEVEL,
            aeperson_filterstr,
            attrlist=AEDIR_AEPERSON_ATTRS,
        )

        for _, res_data, _, _ in aedir_conn.allresults(msg_id):

            for aeperson_dn, aeperson_entry in res_data:

                self.aeperson_counter += 1

                aeuser_result = aedir_conn.search_s(
                    AEDIR_SEARCHBASE,
                    ldap.SCOPE_SUBTREE,
                    '(&%s(aePerson=%s))' % (AEDIR_AEUSER_FILTERSTR, aeperson_dn),
                    attrlist=AEDIR_AEPERSON_ATTRS+['uid', 'uidNumber', 'displayName'],
                )

                # Process the aeUser entries
                for aeuser_dn, aeuser_entry in aeuser_result:

                    new_aeuser_entry = {}
                    new_aeuser_entry.update(aeperson_entry)
                    del new_aeuser_entry['aeStatus']
                    new_aeuser_entry['displayName'] = ['{cn} ({uid}/{uidNumber})'.format(
                        cn=aeperson_entry['cn'][0],
                        uid=aeuser_entry['uid'][0],
                        uidNumber=aeuser_entry['uidNumber'][0],
                    )]

                    # Check whether aeStatus must be updated
                    # First preserve old status
                    aeperson_status = int(aeperson_entry['aeStatus'][0])
                    aeuser_status = int(aeuser_entry['aeStatus'][0])
                    if not aeperson_status <= 0 and aeuser_status <= 0:
                        new_aeuser_entry['aeStatus'] = '1'
                        self.deactivate_counter += 1
                    else:
                        new_aeuser_entry['aeStatus'] = aeuser_entry['aeStatus']

                    # Generate diff of general person attributes
                    modlist = ldap.modlist.modifyModlist(
                        aeuser_entry,
                        new_aeuser_entry,
                        ignore_attr_types=['uid', 'uidNumber']
                    )

                    if not modlist:
                        self.logger.debug(
                            'Nothing to do in %s => skipped',
                            repr(aeuser_dn)
                        )
                    else:
                        self.logger.debug(
                            'Update existing entry %s: %s',
                            repr(aeuser_dn),
                            repr(modlist)
                        )
                        try:
                            aedir_conn.modify_s(aeuser_dn, modlist)
                        except ldap.LDAPError, ldap_err:
                            self.logger.error(
                                'LDAP error modifying %s: %s',
                                repr(aeuser_dn),
                                str(ldap_err)
                            )
                            self.error_counter += 1
                        else:
                            self.logger.info(
                                'Updated entry %s: %s',
                                repr(aeuser_dn),
                                repr(modlist)
                            )
                            self.modify_counter += 1

        # Close LDAP connection
        aedir_conn.unbind_s()

        self.log_summary()

        return # run()


if __name__ == '__main__':
    SyncProcess().run()
