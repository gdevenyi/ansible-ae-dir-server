############################################################################
# monolithic OpenLDAP configuration for AE-DIR provider
# This file MUST NOT be world-readable!
# {{ ansible_managed }}
############################################################################

# Include all the schema files (nested includes therein)
include {{ openldap_schema_prefix }}/init.schema

# Where PID and arg files are stored
pidfile {{ openldap_rundir }}/slapd.pid
argsfile {{ openldap_rundir }}/slapd.args

#---------------------------------------------------------------------------
# Load dynamic backend modules:
#---------------------------------------------------------------------------

moduleload back_mdb
moduleload back_monitor
moduleload back_sock

#---------------------------------------------------------------------------
# Load dynamic overlay modules:
#---------------------------------------------------------------------------

moduleload accesslog
moduleload ppolicy
moduleload memberof
moduleload rwm
# on provider *and* consumer as a work-around for ITS#8396
moduleload syncprov

# contrib modules
moduleload lastbind
moduleload deref
# these would be handy but are not available with LTB packages
#moduleload noopsrch

# only on provider replicas
moduleload constraint
moduleload refint
moduleload unique

#---------------------------------------------------------------------------
# slapd global parameters
#---------------------------------------------------------------------------

# serverID must be unique across all provider replicas
serverID {{ openldap_server_id }}

# which messages to send to syslog
loglevel {{ openldap_log_level }}

# number of worker threads used
threads {{ openldap_threads }}

# additional rootDSE attributes in external LDIF file
rootDSE {{ openldap_conf_prefix }}/rootDSE.ldif

#---------------------------------------------------------------------------
# password hash parameters
#---------------------------------------------------------------------------

password-hash {CRYPT}
# SHA-512, 72 bits) of salt, 5000 iterations
password-crypt-salt-format "$6$%.12s"

#---------------------------------------------------------------------------
# SASL parameters
#---------------------------------------------------------------------------

sasl-host {{ openldap_service_fqdn }}

#---------------------------------------------------------------------------
# TLS parameters
#---------------------------------------------------------------------------

# require at least TLS 1.0
TLSProtocolMin 3.1
TLSVerifyClient allow
TLSCipherSuite DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:AES256-SHA:!ADH

TLSCACertificateFile {{ openldap_cacert_pathname }}
TLSCertificateFile {{ openldap_cert_pathname }}
TLSCertificateKeyFile {{ openldap_key_pathname }}
TLSDHParamFile {{ openldap_dhparam_pathname }}

#---------------------------------------------------------------------------
# Rewrite SASL identity to DIT identity
#---------------------------------------------------------------------------

# Map root user to rootdn when SASL/EXTERNAL is used with LDAPI
authz-regexp
  "gidnumber=0\\+uidnumber=0,cn=peercred,cn=external,cn=auth"
  "cn=root,{{ aedir_suffix }}"

# Map user/group to existing posixAccount entry when SASL/EXTERNAL is used with LDAPI
authz-regexp
  "gidnumber=([0-9]+)\\+uidnumber=([0-9]+),cn=peercred,cn=external,cn=auth"
  "ldap:///{{ aedir_suffix }}??sub?(&(objectClass=posixAccount)(uidNumber=$2)(aeStatus=0))"

# All mechs based on userID most times with password
authz-regexp
  "uid=([a-zA-Z0-9._-]+),cn=(digest-md5|cram-md5|plain|login),cn=auth"
  "ldap:///{{ aedir_suffix }}??sub?(&(|(uid=$1)(host=$1))(aeStatus=0))"

# Rewrite any cert subject-DN by searching it in attribute seeAlso
authz-regexp
  "(cn=[^,]+,{{ openldap_tls_cert_suffix }})"
  "ldap:///{{ aedir_suffix }}??sub?(&(objectClass=pkiUser)(seeAlso=$1)(aeStatus=0))"

# Rewrite server cert subject-DN by searching FQDN in server entry
authz-regexp
  "cn=([a-zA-Z0-9.-]+),{{ openldap_tls_cert_suffix }}"
  "ldap:///{{ aedir_suffix }}??sub?(&(objectClass=aeHost)(host=$1)(aeStatus=0))"
authz-regexp
  "cn=([a-zA-Z0-9.-]+)"
  "ldap:///{{ aedir_suffix }}??sub?(&(objectClass=aeHost)(host=$1)(aeStatus=0))"

# subject name patterns of internal Ã†-DIR PKI
authz-regexp
  "cn=([a-zA-Z0-9.-]+),ou=host,ou=pki,{{ aedir_suffix }}"
  "ldap:///{{ aedir_suffix }}??sub?(&(objectClass=aeHost)(host=$1)(aeStatus=0))"
authz-regexp
  "cn=([a-zA-Z0-9.-]+),ou=uid,ou=pki,{{ aedir_suffix }}"
  "ldap:///{{ aedir_suffix }}??sub?(&(objectClass=account)(uid=$1)(aeStatus=0))"

#---------------------------------------------------------------------------
# Global access control and security restrictions
#---------------------------------------------------------------------------

require LDAPv3

# SSF value for ldapi://
localSSF 256
# minimum required SSF value (security strength factor)
security ssf=128

# allow anonymous access to read standard search base
access to
  dn.base=""
  attrs=objectClass
    by users break
    by * search
access to
  dn.base=""
  attrs=entry
    by * read
access to
  dn.base=""
  attrs=namingContexts
  val.regex="^{{ aedir_suffix }}$"
    by * read

# allow admin access to read all search bases
access to
  dn.base=""
  attrs=namingContexts,configContext,monitorContext
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" read
    by group/aeGroup/member="cn=ae-auditors,cn=ae,{{ aedir_suffix }}" read
    by dn.exact="cn=root,{{ aedir_suffix }}" read
    by * none

# allow all bound users to read rest of rootDSE
access to
  dn.base=""
    by users read

# allow all bound users to read subschema subentry
access to
  dn.base="cn=Subschema"
    by users read

#######################################################################
# Configuration database cn=config (used read-only)
# shall be first database defined
#######################################################################

database config

require strong

access to
  dn.subtree="cn=config"
  attrs=entry,objectClass,olcServerID,olcSaslHost
    by dn.onelevel="cn=ae,{{ aedir_suffix }}" read
    by * none break

access to
  dn.subtree="cn=config"
    by dn.exact="cn=root,{{ aedir_suffix }}" read
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" read
    by group/aeGroup/member="cn=ae-auditors,cn=ae,{{ aedir_suffix }}" read
    by * none

#######################################################################
# Audit database {{ aedir_accesslog_suffix }}
#######################################################################

database mdb

suffix "{{ aedir_accesslog_suffix }}"
directory {{ openldap_data }}/accesslog

require strong

# Always set rootdn since needed by internally writing overlays
rootdn "cn=root,{{ aedir_accesslog_suffix }}"
# rootpw not needed in production!
#rootpw donotenable!!!

lastmod on

# database parameters
maxsize {{ openldap_db_accesslog_maxsize }}
dbnosync
checkpoint 20000 1
envflags writemap

sizelimit -1

# Index-Konfiguration
index reqStart eq
index reqType eq
index reqDN eq
index reqAuthzID eq
index reqResult eq
index reqEntryUUID eq
index objectClass eq

#---------------------------------------------------------------------------
# Access rights {{ aedir_accesslog_suffix }}
#---------------------------------------------------------------------------

access
  to dn.subtree="{{ aedir_accesslog_suffix }}"
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" read
    by group/aeGroup/member="cn=ae-auditors,cn=ae,{{ aedir_suffix }}" read
    by dn.exact="cn=root,{{ aedir_suffix }}" read
    by * none

#---------------------------------------------------------------------------
# overlays used within {{ aedir_accesslog_suffix }}
#---------------------------------------------------------------------------

# for counting search results without retrieving them
#overlay noopsrch

# for dereferencing control
overlay deref

#######################################################################
# Database for {{ aedir_suffix }}
#######################################################################

database mdb

suffix "{{ aedir_suffix }}"
directory {{ openldap_data }}/um

require strong

# Always set rootdn since needed by internally writing overlays
rootdn "cn=root,{{ aedir_suffix }}"
# rootpw not needed in production!
#rootpw donotenable!!!

lastmod on

# database parameters
maxsize {{ openldap_db_um_maxsize }}
dbnosync
checkpoint 20000 1
envflags writemap

add_content_acl yes

#---------------------------------------------------------------------------
# Index configuration
#---------------------------------------------------------------------------

# general eq-only indexes

index objectClass eq
index uid eq
index departmentNumber eq
index uidNumber eq
index gidNumber eq
index member eq
index memberUID eq
index memberOf eq
index sudoUser pres,eq
index seeAlso eq
index modifyTimestamp eq
index mailLocalAddress eq
index mailRoutingAddress eq
# mainly for syncrepl
index entryCSN eq
index entryUUID eq

# for host and network management
index macAddress eq
index ipHostNumber eq
index host sub,eq
index aeFqdn sub,eq

# for aeUser
index aeRemoteHost pres,eq

# sub and eq indexes
index cn sub,eq
index displayName sub,eq
index sn sub,eq
index givenName sub,eq
index mail sub,eq
index o sub,eq
index ou sub,eq

# server groups
index aeLoginGroups eq
index aeVisibleGroups eq
index aeVisibleSudoers eq
index aeProxyFor pres,eq
index aeSSHProxyCommand pres,eq,sub

# service attributes
index aeHost eq

# login-related attributes
index authTimestamp pres,eq
index pwdChangedTime pres,eq
index pwdFailureTime pres,eq

# for person/employee references
index uniqueIdentifier eq
index employeeNumber eq
index aePerson eq

# Meta data
index aeTicketId eq
index aeTag eq,sub

# hardware devices
index serialNumber eq,sub
index aeHwSerialNumber eq,sub

# for OATH-LDAP (index only needed on provider)
index oathHOTPToken eq
index oathHOTPParams eq
index oathTOTPToken eq
index oathTOTPParams eq

#---------------------------------------------------------------------------
# search/time limits for {{ aedir_suffix }}
#---------------------------------------------------------------------------

# no limits for AE admins
limits
  group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}"
    time=unlimited
    size=unlimited

# no limits for AE auditors
limits
  group/aeGroup/member="cn=ae-auditors,cn=ae,{{ aedir_suffix }}"
    time=unlimited
    size=unlimited

# no limits for all zone admins
limits
  group/aeGroup/member="cn=ae-all-zone-admins,cn=ae,{{ aedir_suffix }}"
    time=unlimited
    size=unlimited

# no limits for all zone auditors
limits
  group/aeGroup/member="cn=ae-all-zone-auditors,cn=ae,{{ aedir_suffix }}"
    time=unlimited
    size=unlimited

# no limits for replicas
limits
  group/aeGroup/member="cn=ae-replicas,cn=ae,{{ aedir_suffix }}"
    time=unlimited
    size=unlimited

#---------------------------------------------------------------------------
# access control rules for {{ aedir_suffix }}
#---------------------------------------------------------------------------

# First disallow non-active entities to proceed to rest of ACLs
# by allowing only auth
# This purposely also affects open LDAP connections!
#------------------------------------------------------------------

# block access to all other stuff (except userPassword)
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=!simpleSecurityObject
    by set="user/aeStatus & [0]" break
    by * auth

#---------------------------------------------------------------------------
# The replica ACLs MUST be before secret attributes' ACLs
#---------------------------------------------------------------------------

# Access control for entries/attributes only visible on provider replicas
#---------------------------------------------------------------------------

access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=authTimestamp,pwdFailureTime,pwdHistory,oathSecret,msPwdResetAdminPw
    by group/aeGroup/member="cn=ae-providers,cn=ae,{{ aedir_suffix }}" read
    by group/aeGroup/member="cn=ae-replicas,cn=ae,{{ aedir_suffix }}" none
    by * none break

access to
  dn.subtree="cn={{ aedir_org_zone }},{{ aedir_suffix }}"
    by group/aeGroup/member="cn=ae-providers,cn=ae,{{ aedir_suffix }}" read
    by group/aeGroup/member="cn=ae-replicas,cn=ae,{{ aedir_suffix }}" none
    by * none break

# All replicas can read everything else
access to
  dn.subtree="{{ aedir_suffix }}"
    by group/aeGroup/member="cn=ae-replicas,cn=ae,{{ aedir_suffix }}" read
    by * none break

# Access control for various password attributes
#---------------------------------------------------------------------------

# Password of active token entries may be
# 1. searched  but not read or written(!) by AE-DIR admins
#    FIX ME! For testing is can be written by AE-DIR admins
# 2. written but not read(!) by enrollment service
# 3. removed by self
# 4. used for LDAP simple bind
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=userPassword
  filter="(&(objectClass=oathToken)(aeStatus=0)(pwdPolicySubentry=cn=ppolicy-otptokens,cn=ae,{{ aedir_suffix }}))"
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" =sw
    by dn.base="uid=ae-dir-otpenroll,cn=ae,{{ aedir_suffix }}" =w
    by self =z
    by * auth

# Safety net for bugs in (H/T)OTP validator:
# Block auth access to password of users with assigned OTP token
# because their simple bind requests must be always validated by
# external bind listener.
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=userPassword
  filter="(&(objectClass=aeUser)(aeStatus=0)(pwdPolicySubentry=cn=ppolicy-users,cn=ae,{{ aedir_suffix }})(objectClass=oathUser)(oathToken=*))"
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" =r
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" break
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" break
    by self =w
    by * none

# Active users may authenticate via LDAP simple bind and change own password
access to
  dn.regex="^uid=.+,cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  attrs=userPassword
  filter="(&(objectClass=aeUser)(aeStatus=0))"
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" =sw
    by group/aeGroup/member.expand="cn=${d1}-zone-admins,cn=${d1},{{ aedir_suffix }}" =w
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" =w
    by self =w
    by * auth

# Subordinate aeHost and aeService entries beneath aeSrvGroup entries
access to
  dn.regex="^.+,cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  attrs=userPassword
  filter="(&(|(objectClass=aeHost)(objectClass=aeService))(aeStatus=0))"
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" =sw
    by group/aeGroup/member.expand="cn=${d1}-zone-admins,cn=${d1},{{ aedir_suffix }}" =sw
    by set="user/entryDN & this/-1/aeSetupGroups/member" =sw
    by set="user/entryDN & this/aeSrvGroup/aeSetupGroups/member" =s
    by * auth

# no access to userPassword and pwdHistory as last catch
access to
  attrs=userPassword,pwdHistory
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" =szm
    by * none

# limited manage access (no read!) to pwdHistory only for AE-DIR admins
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=pwdHistory
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" =szm
    by * none

# oathSecret of  may be
# 1. read by OTP validator if token has initialized counter
# 2. searched and written but not read(!) by AE-DIR admins
# 3. deleted but not read(!) by enrollment service
# 4. written but not read(!) self (with temporary password)

access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(&(objectClass=oathToken)(aeStatus=0)(oathHOTPCounter>=0))"
  attrs=oathSecret
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" read
    by * none break

access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(&(objectClass=oathToken)(aeStatus=0))"
  attrs=oathSecret
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" =sw
    by group/aeGroup/member="cn=otp-zone-admins,cn=otp,{{ aedir_suffix }}" =z
    by self =w
    by * none

# no access to oathSecret of inactive entries
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=oathSecret
    by * none

# General ACLs
# This MUST be below ACLs for password attrs!
#---------------------------------------------------------------------------

# Global first-catch ACLs which fire no matter what else happens afterwards...
# AE admins can manage everything else, AE auditors can read everything else
access to
  dn.subtree="{{ aedir_suffix }}"
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" manage
    by group/aeGroup/member="cn=ae-auditors,cn=ae,{{ aedir_suffix }}" read
    by * none break

# Block access to archived entries from here no matter what
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(aeStatus=2)"
    by * none

# Public defaults
#------------------------------------------------------------------

access to
  dn.subtree="cn=pub,{{ aedir_suffix }}"
  attrs=entry,children,objectClass,entryUUID,modifyTimestamp,cn,description,@posixGroup,@sudoRole,@DUAConfigProfile
    by users read

# for OATH-LDAP
#------------------------------------------------------------------

# Access to read all OATH parameter entries for
# 1. OTP validator
# 2. active aeUser entries
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=oathParams)"
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" read
    by set="user/objectClass & [aeUser]" read
    by * none

# write access to special status attributes for OTP validator
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=oathUser)"
  attrs=authTimestamp,pwdFailureTime
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" manage
    by * none break

# read access to password policy DN for OTP validator
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=oathUser)"
  attrs=pwdPolicySubentry
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" read
    by * none break

# write access to special status attributes for OTP validator
access to
  dn.onelevel="cn=otp,{{ aedir_suffix }}"
  filter="(objectClass=oathToken)"
  attrs=oathLastLogin,oathFailureCount,oathLastFailure
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" write
    by group/aeGroup/member="cn=otp-zone-admins,cn=otp,{{ aedir_suffix }}" write
    by * none break

# oathHOTPCounter in token entries may be
#---------------------------------------------------------------------------
# 1. read and (only active) deleted by OTP registration/enrollment admins
# 1. read and (only active) reset to 0 with enrollment password (self)
# 2. read and (only active) written by validation service
# 3. read by OTP registration/enrollment admins
# 4. read by associated users

# allow OTP registration/enrollment admins to add new value 0
access to
  dn.onelevel="cn=otp,{{ aedir_suffix }}"
  filter="(&(objectClass=oathToken)(aeStatus=0))"
  attrs=oathHOTPCounter
  val/integerMatch="0"
    by self =ra
    by * none break

access to
  dn.onelevel="cn=otp,{{ aedir_suffix }}"
  filter="(&(objectClass=oathToken)(aeStatus=0))"
  attrs=oathHOTPCounter
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" write
    by group/aeGroup/member="cn=otp-zone-admins,cn=otp,{{ aedir_suffix }}" =rz
    by set="user/oathHOTPToken & this/entryDN" read
    by self =rz
    by * none

# Token entries can be
#---------------------------------------------------------------------------
# 1. written by OTP registration/enrollment admins
# 2. read by OTP validator
# 3. read by referencing personal user account
# 4. read by zone admins of referencing users
access to
  dn.onelevel="cn=otp,{{ aedir_suffix }}"
  filter="(objectClass=oathToken)"
    by dn.base="uid=ae-dir-otpverify,cn=ae,{{ aedir_suffix }}" read
    by group/aeGroup/member="cn=otp-zone-admins,cn=otp,{{ aedir_suffix }}" write
    by group/aeGroup/member="cn=otp-zone-auditors,cn=otp,{{ aedir_suffix }}" read
    by set="user/oathHOTPToken & this/entryDN" read
    by set="user/entryDN & ([ldap:///{{ aedir_suffix }}?member?sub?(&(objectClass=aeGroup)(aeStatus=0)(cn=*-zone-admins)(member=] + user/entryDN + [))])/member" read
    by * none

# Security zones in general
#------------------------------------------------------------------

# Delegated administration for zone subtrees
access to
  dn.regex="^cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  attrs=children
    by group/aeGroup/member.expand="cn=${d1}-zone-admins,cn=${d1},{{ aedir_suffix }}" write
    by group/aeGroup/member.expand="cn=${d1}-zone-auditors,cn=${d1},{{ aedir_suffix }}" read
    by set="user/-1/entryDN & this/entryDN" search
    by * none break
access to
  dn.regex="^cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
    by group/aeGroup/member.expand="cn=${d1}-zone-admins,cn=${d1},{{ aedir_suffix }}" read
    by group/aeGroup/member.expand="cn=${d1}-zone-auditors,cn=${d1},{{ aedir_suffix }}" read
    by set="user/-1/entryDN & this/entryDN" read
    by users search
    by * none break
# aeSudoRule entries
access to
  dn.regex="^cn=({{ aedir_aesudorule_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeSudoRule)"
    by group/aeGroup/member.expand="cn=${d2}-zone-admins,cn=${d2},{{ aedir_suffix }}" write
    by group/aeGroup/member.expand="cn=${d2}-zone-auditors,cn=${d2},{{ aedir_suffix }}" read
    by * none break
# aeGroup entries add-only attributes
access to
  dn.regex="^cn=({{ aedir_aegroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeGroup)"
  attrs=objectClass,entry,cn,gidNumber
    by group/aeGroup/member.expand="cn=${d2}-zone-admins,cn=${d2},{{ aedir_suffix }}" =arscxd
    by group/aeGroup/member.expand="cn=${d2}-zone-auditors,cn=${d2},{{ aedir_suffix }}" read
    by * none break
# aeGroup entries
access to
  dn.regex="^cn=({{ aedir_aegroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeGroup)"
    by group/aeGroup/member.expand="cn=${d2}-zone-admins,cn=${d2},{{ aedir_suffix }}" write
    by group/aeGroup/member.expand="cn=${d2}-zone-auditors,cn=${d2},{{ aedir_suffix }}" read
    by * none break
# aeUser entries add-only attributes
access to
  dn.regex="^uid=({{ aedir_aeuser_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeUser)"
  attrs=objectClass,entry,uid,uidNumber,aePerson
    by group/aeGroup/member.expand="cn=${d2}-zone-admins,cn=${d2},{{ aedir_suffix }}" =arscxd
    by group/aeGroup/member.expand="cn=${d2}-zone-auditors,cn=${d2},{{ aedir_suffix }}" read
    by * none break
# aeUser entries not archived
access to
  dn.regex="^uid=({{ aedir_aeuser_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeUser)"
  attrs=!msPwdResetObject
    by group/aeGroup/member.expand="cn=${d2}-zone-admins,cn=${d2},{{ aedir_suffix }}" write
    by group/aeGroup/member.expand="cn=${d2}-zone-auditors,cn=${d2},{{ aedir_suffix }}" read
    by * none break
# aeService entries
access to
  dn.regex="^uid=({{ aedir_aeservice_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeService)"
    by group/aeGroup/member.expand="cn=${d2}-zone-admins,cn=${d2},{{ aedir_suffix }}" write
    by group/aeGroup/member.expand="cn=${d2}-zone-auditors,cn=${d2},{{ aedir_suffix }}" read
    by * none break
# aeSrvGroup entries
access to
  dn.regex="^cn=({{ aedir_aesrvgroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeSrvGroup)"
  attrs=children
    by group/aeGroup/member.expand="cn=${d2}-zone-admins,cn=${d2},{{ aedir_suffix }}" write
    by set="user/entryDN & this/aeSetupGroups/member" write
    by set="user/entryDN & this/aeSrvGroup/aeSetupGroups/member" read
    by group/aeGroup/member.expand="cn=${d2}-zone-auditors,cn=${d2},{{ aedir_suffix }}" read
    by * none break
access to
  dn.regex="^cn=({{ aedir_aesrvgroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeSrvGroup)"
    by group/aeGroup/member.expand="cn=${d2}-zone-admins,cn=${d2},{{ aedir_suffix }}" write
    by group/aeGroup/member.expand="cn=${d2}-zone-auditors,cn=${d2},{{ aedir_suffix }}" read
    by set="user/entryDN & this/aeSetupGroups/member" read
    by * none break
# aeHost entries have to be subordinate entries of aeSrvGroup entries
access to
  dn.regex="^host=([a-z]?[a-z0-9.-]+),cn=({{ aedir_aesrvgroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeHost)"
    by group/aeGroup/member.expand="cn=${d3}-zone-admins,cn=${d3},{{ aedir_suffix }}" write
    by set="user/entryDN & this/-1/aeSetupGroups/member" write
    by set="user/entryDN & this/aeSrvGroup/aeSetupGroups/member" read
    by group/aeGroup/member.expand="cn=${d3}-zone-auditors,cn=${d3},{{ aedir_suffix }}" read
    by * none break
# aeService entries can also be subordinate entries of aeSrvGroup
# entries if the need read access to aeUser and aeGroup entries
access to
  dn.regex="^uid=({{ aedir_aeservice_uid_regex }}),cn=({{ aedir_aesrvgroup_cn_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeService)"
    by group/aeGroup/member.expand="cn=${d3}-zone-admins,cn=${d3},{{ aedir_suffix }}" write
    by set="user/entryDN & this/-1/aeSetupGroups/member" write
    by set="user/entryDN & this/aeSrvGroup/aeSetupGroups/member" read
    by group/aeGroup/member.expand="cn=${d3}-zone-auditors,cn=${d3},{{ aedir_suffix }}" read
    by * none break

# Zone cn={{ aedir_org_zone }}
#------------------------------------------------------------------

# administration of aePerson entries beneath zone cn={{ aedir_org_zone }}
access to
  dn.regex="^uniqueIdentifier=({{ aedir_aeperson_uniqueid_regex }}),cn={{ aedir_org_zone }},{{ aedir_suffix }}$"
  filter="(objectClass=aePerson)"
    by group/aeGroup/member.expand="cn={{ aedir_org_zone }}-zone-admins,cn={{ aedir_org_zone }},{{ aedir_suffix }}" write
    by group/aeGroup/member.expand="cn={{ aedir_org_zone }}-zone-auditors,cn={{ aedir_org_zone }},{{ aedir_suffix }}" read
    by * none break
# administration of aeDept entries beneath aeZone cn={{ aedir_org_zone }}
access to
  dn.regex="^departmentNumber=({{ aedir_aedept_deptnumber_regex }}),cn={{ aedir_org_zone }},{{ aedir_suffix }}$"
  filter="(objectClass=aeDept)"
    by group/aeGroup/member.expand="cn={{ aedir_org_zone }}-zone-admins,cn={{ aedir_org_zone }},{{ aedir_suffix }}" write
    by group/aeGroup/member.expand="cn={{ aedir_org_zone }}-zone-auditors,cn={{ aedir_org_zone }},{{ aedir_suffix }}" read
    by * none break

# not-active ACL
#---------------------------------------------------------------------------

# inactive entries are
# 1. readable for all zone admins
# 2. not visible to normal users/systems after this
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(&(aeStatus=*)(!(aeStatus=0)))"
    by set="user/entryDN & ([ldap:///{{ aedir_suffix }}?member?sub?(&(objectClass=aeGroup)(aeStatus=0)(cn=*-zone-admins)(member=] + user/entryDN + [))])/member" break
    by * none

# Password reset with webldappwd.py for active users
#------------------------------------------------------------------

# Access to objectClass value "msPwdResetObject"
# 1. write access for password self-service application
# 2. read access for the user (self)
access to
  dn.regex="^uid=({{ aedir_aeuser_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  attrs=objectClass
  filter="(objectClass=aeUser)"
  val=msPwdResetObject
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" write
    by self read
    by * none

# Access to aeTag value "pub-tag-no-welcome-yet"
# 1. write access for password self-service application
# 2. read access for the user (self)
access to
  dn.regex="^uid=({{ aedir_aeuser_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  attrs=aeTag
  filter="(objectClass=aeUser)"
  val=pub-tag-no-welcome-yet
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" write
    by self read
    by * none

# Restricted access to msPwdReset* password/credential attributes:
# 1. write-only access for password self-service application
# 2. read access for zone admins
access to
  dn.regex="^uid=({{ aedir_aeuser_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeUser)"
  attrs=msPwdResetPasswordHash,msPwdResetAdminPw
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" =w
    by group/aeGroup/member.expand="cn=${d2}-zone-admins,cn=${d2},{{ aedir_suffix }}" read
    by * none

# Access to rest of msPwdReset* attributes
access to
  dn.regex="^uid=({{ aedir_aeuser_uid_regex }}),cn=({{ aedir_aezone_cn_regex }}),{{ aedir_suffix }}$"
  filter="(objectClass=aeUser)"
  attrs=@msPwdResetObject
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" write
    by group/aeGroup/member.expand="cn=${d2}-zone-admins,cn=${d2},{{ aedir_suffix }}" read
    by group/aeGroup/member.expand="cn=${d2}-zone-auditors,cn=${d2},{{ aedir_suffix }}" read
    by self read
    by * none

# Allow read access on necessary attributes
access to
  filter="(objectClass=aeUser)"
  attrs=entry,uid,aeStatus,objectClass,mail,pwdPolicySubentry,pwdChangedTime,aeTag,cn,displayName,description,entryCSN,creatorsName,createTimestamp,modifiersName,modifyTimestamp,memberOf
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" read
    by * none break

# Allow search access to memberOf for special services
access to
  filter="(objectClass=aeUser)"
  attrs=memberOf
    by group/aeGroup/member="cn=ae-login-proxies,cn=ae,{{ aedir_suffix }}" search
    by dn.base="uid=ae-dir-pwd,cn=ae,{{ aedir_suffix }}" search
    by * none break

# Acess to user, group and sudoers entries
#------------------------------------------------------------------

# Give read access to POSIX groups to servers
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=posixGroup)"
  attrs=entry,objectClass,entryUUID,modifyTimestamp,cn,gidNumber,member,memberUID
    by group/aeGroup/member="cn=ae-login-proxies,cn=ae,{{ aedir_suffix }}" read
    by set="user/-1/aeLoginGroups & this/entryDN" read
    by set="user/-1/aeVisibleGroups & this/entryDN" read
    by set="user/-1/aeProxyFor/aeLoginGroups & this/entryDN" read
    by set="user/aeSrvGroup/aeLoginGroups & this/entryDN" read
    by set="user/aeSrvGroup/aeVisibleGroups & this/entryDN" read
    by set="user/aeSrvGroup/aeProxyFor/aeLoginGroups & this/entryDN" read
    by * none break

# Give read access to SUDO rules to servers
access to
  dn.subtree="{{ aedir_suffix }}"
  attrs=entry,objectClass,entryUUID,modifyTimestamp,@sudoRole
  filter="(objectClass=sudoRole)"
    by set="user/-1/aeVisibleSudoers & this/entryDN" read
    by set="user/aeSrvGroup/aeVisibleSudoers & this/entryDN" read
    by * none

# Give read access to SSH public keys to servers which
# shall allow login for the user's groups
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=ldapPublicKey)"
  attrs=sshPublicKey
    by group/aeGroup/member="cn=ae-login-proxies,cn=ae,{{ aedir_suffix }}" read
    by set="user/-1/aeLoginGroups/member & this/entryDN" read
    by set="user/-1/aeProxyFor/aeLoginGroups/member & this/entryDN" read
    by set="user/aeSrvGroup/aeLoginGroups/member & this/entryDN" read
    by set="user/aeSrvGroup/aeProxyFor/aeLoginGroups/member & this/entryDN" read
    by * none break

# Give read access to loginShell to servers which
# shall allow login for the user's groups
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=posixAccount)"
  attrs=loginShell
    by group/aeGroup/member="cn=ae-login-proxies,cn=ae,{{ aedir_suffix }}" read
    by set="user/-1/aeLoginGroups/member & this/entryDN" read
    by set="user/-1/aeProxyFor/aeLoginGroups/member & this/entryDN" read
    by set="user/aeSrvGroup/aeLoginGroups/member & this/entryDN" read
    by set="user/aeSrvGroup/aeProxyFor/aeLoginGroups/member & this/entryDN" read
    by * none break

# Read access to server groups filtered by (objectClass=aeSrvGroup)
#------------------------------------------------------------------

# Read access to aeSetupGroups in aeSrvGroup entries for proxies
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aeSrvGroup)"
  attrs=aeSetupGroups
    by group/aeGroup/member="cn=ae-login-proxies,cn=ae,{{ aedir_suffix }}" read
    by set="user/-1/aeProxyFor & this/entryDN" read
    by set="user/aeSrvGroup/aeProxyFor & this/entryDN" read
    by * none break

# Read access to some attrs of aeSrvGroup entries
# 1. for subordinate aeHost entries
# 2. for SSH proxy aeSrvGroup/aeHost entries
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aeSrvGroup)"
  attrs=entry,objectClass,aeVisibleGroups,aeVisibleSudoers,aeLogStorePeriod,aeLoginGroups,aeLogStoreGroups
    by group/aeGroup/member="cn=ae-login-proxies,cn=ae,{{ aedir_suffix }}" read
    by self.level{1} read
    by set="user/-1/aeProxyFor & this/entryDN" read
    by set="user/aeSrvGroup/aeProxyFor & this/entryDN" read
    by * none break

# Read access to server entries filtered by (objectClass=aeHost)
#------------------------------------------------------------------

access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aeHost)"
  attrs=entry,objectClass,cn,host
    by group/aeGroup/member="cn=ae-login-proxies,cn=ae,{{ aedir_suffix }}" read
    by set="user/-1/aeProxyFor & this/-1/entryDN" read
    by set="user/aeSrvGroup/aeProxyFor & this/-1/entryDN" read
    by * none break

# Personal user accounts filtered by (objectClass=aeUser)
#------------------------------------------------------------------

# self-service attributes of active users
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aeUser)"
  attrs=description
    by self write
    by * none break

# Give read access to POSIX accounts to servers
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=posixAccount)"
  attrs=entry,objectClass,entryUUID,modifyTimestamp,uid,uidNumber,gidNumber,homeDirectory,gecos
    by group/aeGroup/member="cn=ae-login-proxies,cn=ae,{{ aedir_suffix }}" read
    by set="user/-1/aeLoginGroups/member & this/entryDN" read
    by set="user/-1/aeVisibleGroups/member & this/entryDN" read
    by set="user/-1/aeProxyFor/aeLoginGroups/member & this/entryDN" read
    by set="user/aeSrvGroup/aeLoginGroups/member & this/entryDN" read
    by set="user/aeSrvGroup/aeVisibleGroups/member & this/entryDN" read
    by set="user/aeSrvGroup/aeProxyFor/aeLoginGroups/member & this/entryDN" read
    by * none break

# Access to pwdChangedTime of referenced login user groups
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=account)"
  attrs=pwdChangedTime
    by group/aeGroup/member="cn=ae-login-proxies,cn=ae,{{ aedir_suffix }}" read
    by set="user/-1/aeLoginGroups/member & this/entryDN" search
    by set="user/-1/aeProxyFor/aeLoginGroups/member & this/entryDN" search
    by set="user/aeSrvGroup/aeLoginGroups/member & this/entryDN" search
    by set="user/aeSrvGroup/aeProxyFor/aeLoginGroups/member & this/entryDN" search
    by * none break

# Only on providers
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=oathHOTPUser)"
  attrs=oathHOTPToken,oathTOTPToken
    by group/aeGroup/member="cn=ae-login-proxies,cn=ae,{{ aedir_suffix }}" read
    by set="user/-1/aeLoginGroups/member & this/entryDN" search
    by set="user/-1/aeProxyFor/aeLoginGroups/member & this/entryDN" search
    by set="user/aeSrvGroup/aeLoginGroups/member & this/entryDN" search
    by set="user/aeSrvGroup/aeProxyFor/aeLoginGroups/member & this/entryDN" search
    by * none break

# Read access to specific memberOf *values* to all aeHost entries
# where aeSrvGroup references this particular group DN
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=posixAccount)"
  attrs=memberOf
  val.regex="^(.+)$"
    by set.expand="user/-1/entryDN & [ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeSrvGroup)(aeStatus=0)(|(aeLoginGroups=${v1})(aeVisibleGroups=${v1})))]/entryDN" read
    by set.expand="user/aeSrvGroup/entryDN & [ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeSrvGroup)(aeStatus=0)(|(aeLoginGroups=${v1})(aeVisibleGroups=${v1})))]/entryDN" read
    by * none break

# Terminating ACLs for aeZone, aeUser and aeGroup entries
#------------------------------------------------------------------

# Read access to aeZone entries for all aeUser entries beneath the aeZone entry
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aeZone)"
    by set="user/-1/entryDN & this/entryDN" read
    by users search
    by * auth

# Read access to aeGroup entries for all zone admins and all group members
# Note: aeService must not see the groups!
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aeGroup)"
    by set="user/entryDN & ([ldap:///{{ aedir_suffix }}?member?sub?(&(objectClass=aeGroup)(aeStatus=0)(cn=*-admins)(member=] + user/entryDN + [))])/member" read
    by set="this/member & ( [ldap:///] + user/entryDN + [?entryDN?base?(&(objectClass=aeUser)(aeStatus=0))])/entryDN" read
    by * auth

# Read access to aeUser entries for all zone admins and all members which are in same group(s)
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aeUser)"
    by self read
    by set="user/entryDN & ([ldap:///{{ aedir_suffix }}?member?sub?(&(objectClass=aeGroup)(aeStatus=0)(cn=*-admins)(member=] + user/entryDN + [))])/member" read
    by set="this/memberOf & ( [ldap:///] + user/entryDN + [?memberOf?base?(&(objectClass=aeUser)(aeStatus=0))])/memberOf" read
    by * auth

# Read access to aeService entries for all zone admins and all aeUser members which are in same group(s)
# Note: aeService must not see other group members!
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aeService)"
    by set="user/entryDN & ([ldap:///{{ aedir_suffix }}?member?sub?(&(objectClass=aeGroup)(aeStatus=0)(cn=*-admins)(member=] + user/entryDN + [))])/member" read
    by set="this/memberOf & ( [ldap:///] + user/entryDN + [?memberOf?base?(&(objectClass=aeUser)(aeStatus=0))])/memberOf" read
    by * auth

# Password policy entries
#------------------------------------------------------------------

# aeUser entries are allowed to read all password policy entries
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=pwdPolicy)"
    by set="user/entryDN & ([ldap:///] + user/entryDN + [?entryDN?base?(&(objectClass=aeUser)(aeStatus=0))])/entryDN" read
    by * auth

# Read-only (but no administrative) access to active aePerson entries
#---------------------------------------------------------------------------

# Give read access to confidential HR attributes only to
# personal user accounts referencing the person entry
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aePerson)"
  attrs=employeeNumber,aeNotBefore,aeNotAfter
    by set="user/aePerson & this/entryDN" read
    by * none

# Give read access to other attributes to:
# - personal user accounts referencing the person entry
# - all zone admins
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aePerson)"
    by set="user/aePerson & this/entryDN" read
    by set="user/entryDN & ([ldap:///{{ aedir_suffix }}?member?sub?(&(objectClass=aeGroup)(aeStatus=0)(cn=*-zone-admins)(member=] + user/entryDN + [))])/member" read
    by * none break

# restricted addressbook usage of zone cn={{ aedir_org_zone }} for normal users
access to
  dn.subtree="{{ aedir_suffix }}"
  filter="(objectClass=aePerson)"
  attrs=entry,cn,sn,givenName,mail,userCertificate
    by dn.onelevel="cn={{ aedir_base_zone }},{{ aedir_suffix }}" read
    by * none

# Last catch ACLs
#------------------------------------------------------------------

access to
  dn.exact="{{ aedir_suffix }}"
  attrs=entry,children,objectClass,ou,description
    by users read
    by * auth

access to
  dn.subtree="{{ aedir_suffix }}"
    by users search
    by * auth

#---------------------------------------------------------------------------
# overlays used within {{ aedir_suffix }}
#---------------------------------------------------------------------------

# Bind-DN rewriting with internal searches
overlay rwm
rwm-rewriteEngine on
rwm-drop-unrequested-attrs no
# uid=foo,{{ aedir_suffix }} -> entryDN of entry within {{ aedir_suffix }} matching (uid=foo)
rwm-rewriteMap slapd uid2dn "ldap:///{{ aedir_suffix }}?entryDN?sub?"
rwm-rewriteContext bindDN
rwm-rewriteRule "^(uid=[^,]+),{{ aedir_suffix }}$" "${uid2dn($1)}" ":@I"
# host=foo,{{ aedir_suffix }} -> entryDN of entry within {{ aedir_suffix }} matching (host=foo)
rwm-rewriteMap slapd host2dn "ldap:///{{ aedir_suffix }}?entryDN?sub?"
rwm-rewriteContext bindDN
rwm-rewriteRule "^(host=[^,]+),{{ aedir_suffix }}$" "${host2dn($1)}" ":@I"

# for counting search results without retrieving them
#overlay noopsrch

# for dereferencing attributes
overlay deref

# Initialize constraint overlays
overlay unique
overlay constraint

# Check sub-tree wide uniqueness of certain attributes
unique_uri "ldap:///{{ aedir_suffix }}?uid,uidNumber?sub?(objectClass=*)"
unique_uri "ldap:///{{ aedir_suffix }}?mailLocalAddress?sub?(objectClass=*)"
unique_uri "ldap:///{{ aedir_suffix }}?seeAlso?sub?(objectClass=*)"
unique_uri "ldap:///{{ aedir_suffix }}?ipHostNumber,host,aeFqdn?sub?(objectClass=*)"
unique_uri "ldap:///cn={{ aedir_org_zone }},{{ aedir_suffix }}?employeeNumber,uniqueIdentifier,displayName?sub"
# only one primary aeUser entry per aePerson
unique_uri "ldap:///cn={{ aedir_base_zone }},{{ aedir_suffix }}?aePerson?sub"
# these two constraints are only possible with a negation filter
unique_uri "ldap:///{{ aedir_suffix }}?cn?sub?(!(|(objectClass=aePerson)(objectClass=aeUser)(objectClass=aeNwDevice)))"
unique_uri "ldap:///{{ aedir_suffix }}?gidNumber?sub"

constraint_attribute
  host
  regex "^[a-zA-Z0-9.-]+$"

constraint_attribute
  uniqueIdentifier
  regex "^{{ aedir_aeperson_uniqueid_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aePerson)"

constraint_attribute
  departmentNumber
  regex "^{{ aedir_aedept_deptnumber_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeDept)"

constraint_attribute
  uid
  regex "^{{ aedir_aeuser_uid_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"
constraint_attribute
  uid
  regex "^{{ aedir_aeservice_uid_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeService)"
constraint_attribute
  uid
  count 1
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeObject)"

# Regex constraint on 'cn' in zone entries
constraint_attribute
  cn
  regex "^{{ aedir_aezone_cn_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeZone)"

# check whether gidNumber is within valid range (see aeRoot)
constraint_attribute gidNumber set
  "(this/-2/entryDN & ([ldap:///]+this/-2/entryDN+[?entryDN?base?(&(objectClass=aeRoot)(entryDN=]+this/-2/entryDN+[)(aeGidNumberMin<=]+this/gidNumber+[)(aeGidNumberMax>=]+this/gidNumber+[))])/entryDN"
  restrict="ldap:///ou=ae-dir??sub"
  restrict="ldap:///{{ aedir_suffix }}??sub?(&(|(objectClass=posixAccount)(objectClass=posixGroup))(!(entryDN:dnOneLevelMatch:=cn=ae,{{ aedir_suffix }})))"

# check whether uidNumber is within valid range (see aeRoot)
constraint_attribute uidNumber set
  "(this/-2/entryDN & ([ldap:///]+this/-2/entryDN+[?entryDN?base?(&(objectClass=aeRoot)(entryDN=]+this/-2/entryDN+[)(aeUidNumberMin<=]+this/uidNumber+[)(aeUidNumberMax>=]+this/uidNumber+[))])/entryDN"
  restrict="ldap:///ou=ae-dir??sub"
  restrict="ldap:///{{ aedir_suffix }}??sub?(&(|(objectClass=posixAccount)(objectClass=posixGroup))(!(entryDN:dnOneLevelMatch:=cn=ae,{{ aedir_suffix }})))"

# uidNumber and gidNumber in posixAccount entries must be the same value
constraint_attribute uidNumber,gidNumber
  set "this/uidNumber & this/gidNumber"
  restrict="ldap:///{{ aedir_suffix }}??sub?(&(objectClass=posixAccount)(!(entryDN:dnOneLevelMatch:=cn=ae,{{ aedir_suffix }})))"

# Treat 'cn' as SINGLE-VALUE by constraint
constraint_attribute
  cn
  count 1
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeObject)"

# naming convention for 'cn' in 'aeSrvGroup' entries
constraint_attribute
  cn
  regex "^{{ aedir_aesrvgroup_cn_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeSrvGroup)"

# naming convention for 'cn' in 'aeGroup' entries
constraint_attribute
  cn
  regex "^{{ aedir_aegroup_cn_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeGroup)"

# naming convention for 'cn' in 'aeSudoRule' entries
constraint_attribute
  cn
  regex "^{{ aedir_aesudorule_cn_regex }}$"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeSudoRule)"

# attribute 'mobile'
constraint_attribute
  mobile
  regex "^\\+[1-9]?[0-9 -]+$"

# naming convention for 'aeTicketId'
constraint_attribute
  aeTicketId
  regex "^{{ aeticketid_regex }}$"

constraint_attribute
  sshPublicKey
  regex "(^|.* )ssh-(rsa|dss|ecdsa-sha2-nistp256) .+$"

# restrict values of aeLoginGroups and aeVisibleGroups to DNs of active aeGroup entries
# Excluded are special role groups:
# - ae-admins, ae-auditors and ae-login-proxies
# - zone-admins and zone-auditors
# - pub-*
constraint_attribute
  aeLoginGroups
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeGroup)(aeStatus=0)(!(|(cn=ae-admins)(cn=ae-auditors)(cn=ae-provider)(cn=ae-replicas)(cn=ae-login-proxies)(cn=*-zone-admins)(cn=*-zone-auditors))))"
  restrict="ldap:///{{ aedir_suffix }}??sub"
constraint_attribute
  aeVisibleGroups
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeGroup)(aeStatus=0)(!(|(cn=ae-admins)(cn=ae-auditors)(cn=ae-provider)(cn=ae-replicas)(cn=ae-login-proxies)(cn=*-zone-admins)(cn=*-zone-auditors))))"
  restrict="ldap:///{{ aedir_suffix }}??sub"

# restrict values of aeVisibleSudoers to DNs of active aeSudoRule entries
constraint_attribute
  aeVisibleSudoers
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeSudoRule)(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub"

# restrict references from personal user accounts to their person entries
constraint_attribute
  aePerson
  uri "ldap:///cn={{ aedir_org_zone }},{{ aedir_suffix }}?entryDN?sub?(objectClass=aePerson)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"
# if parent aeZone entry has aeDept set then it must match aeDept in aePerson
constraint_attribute aePerson,entryDN set
  "this/-1/entryDN & ([ldap:///] + this/-1/entryDN + [?entryDN?base?(&(objectClass=aeZone)(|(!(aeDept=*))(aeDept=] + this/aePerson/aeDept + [)))])/entryDN"
  restrict="ldap:///ou=ae-dir??sub?(objectClass=aeUser)"

# restrict tag references
constraint_attribute
  aeTag
  uri "ldap:///{{ aedir_suffix }}?cn?sub?(&(objectClass=aeTag)(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub?"

# restrict aeProxyFor in aeSrvGroup entry to reference solely active non-proxy aeSrvGroup in same zone
constraint_attribute
  aeProxyFor
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeSrvGroup)(aeStatus=0)(!(aeProxyFor=*)))"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeSrvGroup)"
constraint_attribute aeProxyFor,entryDN set
  "this/aeProxyFor/-1/entryDN & this/entryDN/-1/entryDN"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeSrvGroup)"

# restrict aeSrvGroup in aeHost entry to reference solely active aeSrvGroup in same zone
constraint_attribute
  aeSrvGroup
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeSrvGroup)(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeSrvGroup)"
constraint_attribute aeSrvGroup,entryDN set
  "this/aeSrvGroup/-1/entryDN & this/entryDN/-1/-1/entryDN"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeHost)"

# restrict aeHost in aeService entry to reference solely active aeHost entry
constraint_attribute
  aeSrvGroup
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeHost)(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeService)"

# restrict references from user groups to have only active personal
# and system user accounts as members
constraint_attribute
  member
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(|(objectClass=aeUser)(objectClass=aeService))(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=groupOfEntries)"

# 'mail' the same in personal user accounts and referenced person entries
constraint_attribute aePerson,mail set
  "this/aePerson/mail & this/mail"
  restrict="ldap:///{{ aedir_suffix }}??sub?(&(objectClass=aeUser)(!(objectClass=inetLocalMailRecipient)))"

# 'givenName' the same in personal user accounts and referenced person entries
constraint_attribute aePerson,givenName set
  "this/aePerson/givenName & this/givenName"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"

# 'sn' the same in personal user accounts and referenced person entries
constraint_attribute aePerson,sn
  set "this/aePerson/sn & this/sn"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"

# 'sudoUser' only may contain a reference to 'cn' of an active group
constraint_attribute sudoUser
  set "([%] + [ldap:///{{ aedir_suffix }}??sub?(&(objectClass=aeGroup)(aeStatus=0)(!(|(cn=ae-admins)(cn=ae-auditors)(cn=ae-provider)(cn=ae-replicas)(cn=ae-login-proxies)(cn=*-zone-admins)(cn=*-zone-auditors))))]/cn) & this/sudoUser"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeSudoRule)"

# 'homeDirectory' must be composed as /home/<uid> for 'aeUser' entries
constraint_attribute uid,homeDirectory
  set "([/home/] + this/uid) & this/homeDirectory"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"

# displayName in personal user account must be composed based on "<cn> (<uid>/<uidNumber>)"
constraint_attribute displayName,cn,uid,uidNumber
  set "(this/cn + [ (] + this/uid + [/] + this/uidNumber + [)]) & this/displayName"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeUser)"

# cn in aeUser or aePerson entry must be composed based on "<givenName> <sn>"
constraint_attribute cn,sn,givenName
  set "(this/givenName + [ ] + this/sn) & this/cn"
  restrict="ldap:///{{ aedir_suffix }}??sub?(|(objectClass=aePerson)(objectClass=aeUser))"

# restrict memberUID to be consistent with group membership defined in member
constraint_attribute memberUID,member
  set "this/memberUID & this/member/uid"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=aeGroup)"

# the Yubikey serial number must be the same in various attributes
# Example:
# cn: yubikey-1543514
# displayName: Yubikey NEO 1543514
# oathTokenIdentifier: ubhe01543514
# oathTokenSerialNumber: 1543514
# serialNumber: yubikey-1543514
# aeHwSerialNumber: 1543514
constraint_attribute
  aeHwSerialNumber
  regex "^[0-9]{0,8}$"
constraint_attribute
  serialNumber,cn,aeHwSerialNumber
  set "this/serialNumber & this/cn & ([yubikey-] + this/aeHwSerialNumber)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=oathHOTPToken)"
constraint_attribute
  displayName,aeHwSerialNumber
  set "this/displayName & ([yubikey neo #] + this/aeHwSerialNumber)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=oathHOTPToken)"
constraint_attribute
  oathTokenSerialNumber,aeHwSerialNumber
  set "this/oathTokenSerialNumber & this/aeHwSerialNumber"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=oathHOTPToken)"
constraint_attribute
  oathTokenIdentifier
  regex "^ubhe[0-9]{8}$"
# FIX ME! Not sure how to match "ubhe"*<oathTokenIdentifier>
#constraint_attribute
#  oathTokenIdentifier,aeHwSerialNumber
#  set " & ([uhbe] + this/aeHwSerialNumber) & this/oathTokenIdentifier"
#  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=oathHOTPToken)"

# standard constraints for OATH-LDAP
#constraint_attribute
#  oathHOTPToken
#  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(objectClass=oathHOTPToken)"
#  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=oathHOTPUser)"
constraint_attribute
  oathHOTPParams
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(objectClass=oathHOTPParams)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=oathHOTPToken)"


# Constraints on applicable password policy for certain object classes in certain zone
constraint_attribute pwdPolicySubentry
  uri "ldap:///cn=ppolicy-users,cn=ae,{{ aedir_suffix }}?entryDN?base?(objectClass=pwdPolicy)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(&(objectClass=aeUser)(!(entryDN:dnSubtreeMatch:=cn={{ aedir_base_zone }},ou=ae-dir)))"
constraint_attribute pwdPolicySubentry
  uri "ldap:///cn=ppolicy-base-users,cn=ae,{{ aedir_suffix }}?entryDN?base?(objectClass=pwdPolicy)"
  restrict="ldap:///cn={{ aedir_base_zone }},{{ aedir_suffix }}??sub?(objectClass=aeUser)"
constraint_attribute pwdPolicySubentry
  uri "ldap:///cn=ppolicy-systems,cn=ae,{{ aedir_suffix }}?entryDN?base?(objectClass=pwdPolicy)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(|(objectClass=aeHost)(objectClass=aeService))"
constraint_attribute pwdPolicySubentry
  uri "ldap:///cn=ppolicy-otptokens,cn=ae,{{ aedir_suffix }}?entryDN?base?(objectClass=pwdPolicy)"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=oathToken)"


# restrict memberUID to be consistent with group membership defined in member
constraint_attribute memberUID
  uri "ldap:///{{ aedir_suffix }}?uid?sub?(&(objectClass=posixAccount)(aeStatus=0))"
  restrict="ldap:///{{ aedir_suffix }}??sub?(objectClass=posixGroup)"

# restrict references from aeHost/aeService to active aeSrvGroup entries
constraint_attribute
  aeSrvGroup
  uri "ldap:///{{ aedir_suffix }}?entryDN?sub?(&(objectClass=aeSrvGroup)(aeStatus=0))"

# Where to log LDAP write operations (for auditing)
overlay accesslog
logdb "{{ aedir_accesslog_suffix }}"
logops writes
logold "(objectClass=*)"
logoldattr entryUUID objectClass cn uid
# keep for 3660 days (~ 10 years) and scan once per week
logpurge 3660+00:00 07+00:00

# Referential integrity checking
overlay refint
refint_attributes
  aeHost
  aeLoginGroups
  aeLogStoreGroups
  aePerson
  aeProxyFor
  aeSetupGroups
  aeSrvGroup
  aeVisibleGroups
  aeVisibleSudoers
  manager
  member
  oathHOTPParams
  oathHOTPToken
  oathTOTPParams
  oathTOTPToken
  seeAlso

# for back-links to group entries in member entries
overlay memberof
memberof-group-oc aeGroup
memberof-member-ad member
memberof-memberof-ad memberOf
memberof-dangling ignore
memberof-refint true

# Record last bind in user entry
# (after bind-DN rewriting with slapo-rwm)
overlay lastbind

# password policy overlay
# (after bind-DN rewriting with slapo-rwm)
overlay ppolicy
# the default password policy is deliberatly unusable
ppolicy_default cn=ppolicy-default,cn=ae,{{ aedir_suffix }}
ppolicy_hash_cleartext
ppolicy_use_lockout

#---------------------------------------------------------------------------
# replication of {{ aedir_suffix }}
#---------------------------------------------------------------------------

# syncrepl-Overlay
overlay syncprov
syncprov-checkpoint 1000 2
syncprov-reloadhint TRUE

{% if openldap_syncrepl_providers %}
{% for provider_replica in openldap_syncrepl_providers if provider_replica!=openldap_service_fqdn %}
syncrepl rid=0{{ loop.index }}
  provider=ldaps://{{ provider_replica }}
  type=refreshAndPersist
  interval=00:00:01:00
  retry="30 +"
  searchbase="{{ aedir_suffix }}"
  filter="(objectClass=*)"
  scope=sub
  schemachecking=on
  bindmethod=sasl
  saslmech=EXTERNAL
  tls_cacert={{ openldap_cacert_pathname }}
  tls_cert={{ openldap_cert_pathname }}
  tls_key={{ openldap_key_pathname }}

{% endfor %}

mirrormode true
{% endif %}

#######################################################################
# Monitoring backend cn=Monitor
# shall be last database defined
#######################################################################

database monitor

require strong

access to
  dn.subtree="cn=monitor"
    by group/aeGroup/member="cn=ae-admins,cn=ae,{{ aedir_suffix }}" read
    by group/aeGroup/member="cn=ae-auditors,cn=ae,{{ aedir_suffix }}" read
    by dn.exact="cn=root,{{ aedir_suffix }}" read
    by * none
